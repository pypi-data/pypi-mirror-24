#
# Copyright (c) 2016 BlueData Software, Inc.
#

from __future__ import print_function
from ... import SubCommand
from ...constants import DEFAULT_BOOL_FALSE
from ...inmem_store import SIMPLESETUP_DICT, ENTRY_DICT

import os
import shutil
import argparse

from .addfile import autogenAddfile
from .replace import autogenReplace
from .perms import autogenPermission
from .append import autogenAppend
from .execute import autogenExecute
from .services import autogenServiceRegistration
from ...utils.config import SECTION_WB, KEY_SDKBASE, KEY_APPCONFIGDIR, KEY_STAGEDIR
from ...utils.misc import checkConfigApiVersion

def copyAppconfigStarter(config, packagePath):
    """

    """
    if not os.path.exists(packagePath):
        os.makedirs(packagePath)

    sdkbase = config.get(SECTION_WB, KEY_SDKBASE)
    commonScriptsDir = os.path.join(sdkbase, 'appbuild', 'config_scripts_common')
    for f in os.listdir(commonScriptsDir):
        src = os.path.join(commonScriptsDir, f)
        dst = os.path.join(packagePath, f)
        # Special case for appjob script.
        # We want to copy that template only if it doesn't already exist. The
        # premise is that it not autogenerated and the user may have modified
        # it to suite the specific app so, we should not overwrite it.
        if (f == "appjob") and os.path.exists(dst):
            continue


        shutil.copy2(src, dst)

class AppconfigAutogen(SubCommand):
    """

    """
    def __init__(self, config, inmemStore, parent):
        SubCommand.__init__(self, config, inmemStore, parent, 'autogen')

    def getSubcmdDescripton(self):
        return 'Autogenerate a simple appconfig bundle.'

    def populateParserArgs(self, subparser):
        subparser.add_argument('--new', action='store_true', dest='new',
                               default=False,
                               help='Appconfig package name. Overrides any '
                                    'previous autogeneration package progress.')
        subparser.add_argument('--configapi', action='store', dest='configapi',
                                default=None,
                                help='The config api version used by the '
                                'appconfig package.')
        subparser.add_argument('--generate', action='store_true', dest='generate',
                               default=DEFAULT_BOOL_FALSE,
                               help='Autogenerate the appconfig package previously '
                                    'created using --new argument.')

        addfile_group = subparser.add_argument_group(title='File additions',
                        description='Copy files to the deployed node.')
        addfile_group.add_argument('--pkgfile', metavar='FILE_IN_APPCONFIG_PKG',
                                   dest='pkgfile', action='store', nargs='+',
                                   default=None,
                                   help='The name(s) of the file(s) already in '
                                   'the appconfig directory are used as the '
                                   'source file(s).')
        addfile_group.add_argument('--destdir', metavar='ABS_DEST_DIR',
                                   dest='destdir', action='store',
                                   help='Destination directory where a given '
                                   'file(s) is(are) to be copied on a deployed '
                                   'node.')
        addfile_group.add_argument('--dest', metavar='ABSOLUTE_PATH', type=str,
                                   dest='destpath', action='store',
                                   help='Absolute path where the local file '
                                        'should be placed inside the container. '
                                        'Any directories necessary to put the '
                                        'file at the location are created.')

        append_group = subparser.add_argument_group(title='File Append',
                        description='Append files with cluster specific properties')
        append_group.add_argument('--append', metavar="FILENAME", type=str,
                               dest='append', action="store", nargs=1,
                               help="Absolute path of the config file inside "
                                    "the container.")
        execute_group = subparser.add_argument_group(title='File Execute',
                        description='Execute shell')
        execute_group.add_argument('--execute', metavar="FILENAME", type=str,
                               dest='execute', action="store", nargs=1,
                               help="Absolute path of the file to"
                                     "be executed inside the container")

        perms_group = subparser.add_argument_group(title='File permissions',
                        description='Assign permissions to files or '
                                    'directories in the container image.')
        perms_group.add_argument('--abspath', metavar="ABSOLUTE_PATH", type=str,
                                 dest='abspath', action='store',
                                 help='Absolute path of the file or director whose '
                                      'permissions to set.')
        perms_group.add_argument('--perms', metavar="PERMISSION", type=str,
                                 dest='perms', action='store',
                                 help='RWX permissions to set for this file/directory.')
        perms_group.add_argument('--uid', metavar="UID", type=str, dest='uid',
                                 action='store',
                                 help='UID to set for the file or directory.')
        perms_group.add_argument('--gid', metavar="GID", type=str, dest='gid',
                                 action='store',
                                 help='GID to set for the file or directory.')

        replace_group = subparser.add_argument_group(title="Pattern replacement",
                        description="Pattern replacement instructions for "
                                    "autogenerating config file customization.")
        replace_group.add_argument('--replace', metavar="FILENAME", type=str,
                               dest='replace', action="store",
                               help="Absolute path of the config file inside "
                                    "the container.")
        replace_group.add_argument('--pattern', metavar="PATTERN", type=str,
                               dest='pattern', action="store",
                               help="The pattern in the configuration file to "
                                    "replace.")
        replace_group.add_argument('--macro', metavar="MACRO", type=str,
                               dest='macro', nargs=argparse.REMAINDER,
                               help="A command whose output is used to replace "
                                    "the pattern. This could be a SDK defined "
                                    "function or a simple command invocation.")

        srvc_group = subparser.add_argument_group(title="Service registration",
                        description="Services information for autogenerating "
                                    "the registration code. These services are "
                                    "only registered and started if the specific "
                                    "node is expected to run the service.")
        srvc_group.add_argument("--srvcid", metavar="SERVICE_ID", type=str,
                                dest="srvcid", action="store",
                                help="Service id to register and start.")
        srvc_group.add_argument("--sysv", metavar="SYSTEMV", type=str,
                                dest="sysv", action="store",
                                help="SystemV service name.")
        return

    def run(self, pArgs):
        if hasattr(pArgs, 'error') and pArgs.error:
            return False

        stagingDir = self.config.get(SECTION_WB, KEY_STAGEDIR)
        appconfigDir = self.config.get(SECTION_WB, KEY_APPCONFIGDIR)

        if pArgs.new:
            if not pArgs.configapi:
                print("ERROR: --configapi must be specified along with --new")
                return False

            checkConfigApiVersion(pArgs.configapi)

            packageName = os.path.basename(appconfigDir) + ".tgz"
            self.inmemStore.addField(SIMPLESETUP_DICT, "autogen",
                                                            {
                                                                'name'   : packageName,
                                                                'package': appconfigDir,
                                                                'configapi': pArgs.configapi,
                                                                'append' : {},
                                                                'execute': [],
                                                                'replace': [],
                                                                'addfile': {},
                                                                'perms'  : {},
                                                                'services': {}
                                                            })

            return True

        try:
            autogen = self.inmemStore.getDict(SIMPLESETUP_DICT)["autogen"]
        except KeyError:
            print("ERROR: 'appconfig autogen --new --configapi <VER>' must "
                  "already be executed.")
            return False

        if pArgs.pkgfile:
            if (pArgs.destpath == None) and (pArgs.destdir == None):
                print("ERROR: --dest or --destdir must be specified with --pkgfile.")
                return False

            if (pArgs.destpath != None) and (not os.path.isabs(pArgs.destpath)):
                print("ERROR: --dest must specify an absolute path.")
                return False

            if (pArgs.destdir != None) and (not os.path.isabs(pArgs.destdir)):
                print("ERROR: --destdir must specify an absolute path.")
                return False

            for f in pArgs.pkgfile:
                if not os.path.exists(os.path.join(appconfigDir, f)):
                    print("ERROR: File '%s' missing in '%s'." % (f, appconfigDir))
                    return False

                autogen['addfile'][f] = {'dstfile': pArgs.destpath,
                                         'dstdir' : pArgs.destdir}

        if pArgs.append:
            if (pArgs.append == None) or (not pArgs.macro):
                print("ERROR: --append and macro must be specified")
                return False

            if (pArgs.append != None) and (not os.path.isabs(pArgs.append)):
                print("ERROR: --append must specify an absolute path.")
                return False
            macroParams = ' '.join(pArgs.macro)
            autogen['append'] = { pArgs.append : macroParams}

        if pArgs.execute:
              if (pArgs.execute == None):
                 print("ERROR: --execute must be specified")
                 return False
              executeList=autogen['execute']
              autogen['execute'] = executeList + pArgs.execute

        elif pArgs.abspath:
            if not pArgs.perms:
                print("ERROR: --prems must be specified with --abspath.")
                return False

            filepath = pArgs.abspath
            autogen['perms'][filepath] = {'rwx': pArgs.perms}
            if pArgs.uid:
                autogen['perms'][filepath]['uid'] = pArgs.uid

            if pArgs.gid:
                if not pArgs.uid:
                    print("ERROR: --gid must be used along with --uid.")
                    return False
                autogen['perms'][filepath]['uid'] = pArgs.gid
        elif pArgs.replace:
            if (not pArgs.pattern) or (not pArgs.macro):
                print("ERROR: Both --pattern and --macro are required args with --repalce.")
                return False

            path = pArgs.replace
            replaceList = autogen['replace']
            replaceList.append({'path' : path,
                                'substitute' : {'pattern': pArgs.pattern,'macro' : pArgs.macro}})
        elif pArgs.srvcid:
            if not pArgs.sysv:
                print("ERROR: --sysv must be specified with --srvcid.")
                return False

            autogen['services'][pArgs.srvcid] = { 'sysv': pArgs.sysv}
        elif pArgs.generate:
            return self._build_appconfig_package(autogen, self.inmemStore.getDict(ENTRY_DICT))

        return True

    def complete(self, text, argsList):
        return []

    def _build_appconfig_package(self, autogenDict, entryDict):
        """

        """
        packagePath = autogenDict["package"]

        try:
            # Don't remove the entire directory as the developer may have
            # some additional files in the directory. Instead, only overwrite
            # the files copied by the SDK.
            copyAppconfigStarter(self.config, packagePath)

            # Append the newly generated code block to the startscript.
            with open(os.path.join(packagePath, 'startscript'), 'a') as f:
                lines = []
                autogenAddfile(lines, packagePath, autogenDict, entryDict)
                autogenReplace(lines, autogenDict, entryDict)
                autogenAppend(lines, autogenDict, entryDict)
                autogenPermission(lines, autogenDict, entryDict)
                autogenExecute(lines, autogenDict, entryDict)
                autogenServiceRegistration(lines, autogenDict, entryDict)

                f.writelines(lines)
                f.flush()

            print("Successfully auto generated: %s" % (autogenDict['name']))
            return True
        except Exception as e:
            print("EXCEPTION while generating appconfig: ", e)
            return False

__all__ = [ "AppconfigAutogen", "copyAppconfigStarter" ]
SubCommand.register(AppconfigAutogen)
