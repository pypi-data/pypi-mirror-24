#!/usr/bin/env python
# -*- coding: utf-8 -*-

import numpy as np
import networkx as nx
import matplotlib.pyplot as plt

def get_interlocutors(x, y):
    z = [x, y]
    z.sort()
    z = z[0] + "|" + z[1]
    return z
    

def get_my_network(df_target, sender_column, addressee_column, graph_name, generate_png=False, generate_gexf=False, top_n=None):
    '''
    'get_my_network' function from pyple package take as parameters a dataframe with 2 columns representing an exchange like sender-addressee. 
    The second parameter will be the name of the first column, the third parameter will be the name of the second column. 
    Using the fourth parameter you will give a name to your network as a file and as a plot graphic too.
    You can choose with the 5th and the 6th parameters to save the result as .png ou .gexf.
    If you don't specified these arguments, they won't be generated by default.
    The last parameter is optional and allow us to choose the number of the best interactions you want to work with.
    Without the 'top_n' argument, the function will work with the all interactions of your dataframe.
    Once this function will be executed, an array will be return with:
    - index 0: your dataframe concatenated
    - index 1: a python plot of your network
    - index 2: the final Graph value
    '''

    df_target['Interlocutors'] = np.vectorize(get_interlocutors)(sender_column, addressee_column)
    
    s_target_concat = df_target.groupby(['Interlocutors']).size()
    df_target_concat = s_target_concat.reset_index()
    df_target_concat.columns = ['Interlocutors', 'Interactions']

    s = df_target_concat['Interlocutors'].apply(lambda x: x.split('|'))
    df_target_concat['Interlocutor_1'] = s.apply(lambda x: x[0])
    df_target_concat['Interlocutor_2'] = s.apply(lambda x: x[1])
    
    # TOP link_number
    if top_n == None:
        print("We took ", len(df_target_concat), "interactions with this dataframe")
    else:
        df_target_concat = df_target_concat.sort_values(by = ['Interactions'], ascending=[False]).head(top_n)
    
    df_target_concat = df_target_concat.reset_index()
    df_target_concat = df_target_concat[['Interlocutor_1', 'Interlocutor_2', 'Interactions']]
    
    #Graph
    G_target = nx.Graph()
    
    for i in range(len(df_target_concat)):
        G_target.add_edge(df_target_concat["Interlocutor_1"][i], df_target_concat["Interlocutor_2"][i], weight = df_target_concat["Interactions"][i])
    
    elarge = [(u,v) for (u,v,d) in G_target.edges(data=True) if d['weight'] > df_target_concat.Interactions.mean()]
    esmall = [(u,v) for (u,v,d) in G_target.edges(data=True) if d['weight'] <= df_target_concat.Interactions.mean()]

    pos = nx.spring_layout(G_target)
    
    nx.draw_networkx_edges(G_target, pos, edgelist=elarge, width=3, edge_color='black')
    nx.draw_networkx_edges(G_target, pos, edgelist=esmall, width=3, alpha=0.5, edge_color='black', style='dashed')
    nx.draw_networkx_nodes(G_target, pos, node_size=50)    
    nx.draw_networkx_labels(G_target, pos, font_size=10, font_family='sans-serif', font_color="green")
    
    plt.axis('off')
    plt.title(graph_name)
    if generate_png:
        plt.savefig(path_png)

    if generate_gexf:
        path_gexf = graph_name + ".gexf"
        nx.write_gexf(G_target, path_gexf)
    
    network_info = [df_target_concat, plt, G_target]
    
    return network_info 


if __name__ == '__main__':
    print("Bonjour")
    #introduction()