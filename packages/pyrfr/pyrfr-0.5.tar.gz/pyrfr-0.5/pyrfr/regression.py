# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_regression')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_regression')
    _regression = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_regression', [dirname(__file__)])
        except ImportError:
            import _regression
            return _regression
        try:
            _mod = imp.load_module('_regression', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _regression = swig_import_helper()
    del swig_import_helper
else:
    import _regression
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

class default_random_engine(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, default_random_engine, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, default_random_engine, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _regression.new_default_random_engine(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def seed(self, arg2):
        return _regression.default_random_engine_seed(self, arg2)
    __swig_destroy__ = _regression.delete_default_random_engine
    __del__ = lambda self: None
default_random_engine_swigregister = _regression.default_random_engine_swigregister
default_random_engine_swigregister(default_random_engine)

class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _regression.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self):
        return _regression.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _regression.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _regression.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _regression.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _regression.SwigPyIterator_equal(self, x)

    def copy(self):
        return _regression.SwigPyIterator_copy(self)

    def next(self):
        return _regression.SwigPyIterator_next(self)

    def __next__(self):
        return _regression.SwigPyIterator___next__(self)

    def previous(self):
        return _regression.SwigPyIterator_previous(self)

    def advance(self, n):
        return _regression.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _regression.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _regression.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _regression.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _regression.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _regression.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _regression.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _regression.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class num_vector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, num_vector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, num_vector, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _regression.num_vector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _regression.num_vector___nonzero__(self)

    def __bool__(self):
        return _regression.num_vector___bool__(self)

    def __len__(self):
        return _regression.num_vector___len__(self)

    def __getslice__(self, i, j):
        return _regression.num_vector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _regression.num_vector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _regression.num_vector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _regression.num_vector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _regression.num_vector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _regression.num_vector___setitem__(self, *args)

    def pop(self):
        return _regression.num_vector_pop(self)

    def append(self, x):
        return _regression.num_vector_append(self, x)

    def empty(self):
        return _regression.num_vector_empty(self)

    def size(self):
        return _regression.num_vector_size(self)

    def swap(self, v):
        return _regression.num_vector_swap(self, v)

    def begin(self):
        return _regression.num_vector_begin(self)

    def end(self):
        return _regression.num_vector_end(self)

    def rbegin(self):
        return _regression.num_vector_rbegin(self)

    def rend(self):
        return _regression.num_vector_rend(self)

    def clear(self):
        return _regression.num_vector_clear(self)

    def get_allocator(self):
        return _regression.num_vector_get_allocator(self)

    def pop_back(self):
        return _regression.num_vector_pop_back(self)

    def erase(self, *args):
        return _regression.num_vector_erase(self, *args)

    def __init__(self, *args):
        this = _regression.new_num_vector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _regression.num_vector_push_back(self, x)

    def front(self):
        return _regression.num_vector_front(self)

    def back(self):
        return _regression.num_vector_back(self)

    def assign(self, n, x):
        return _regression.num_vector_assign(self, n, x)

    def resize(self, *args):
        return _regression.num_vector_resize(self, *args)

    def insert(self, *args):
        return _regression.num_vector_insert(self, *args)

    def reserve(self, n):
        return _regression.num_vector_reserve(self, n)

    def capacity(self):
        return _regression.num_vector_capacity(self)
    __swig_destroy__ = _regression.delete_num_vector
    __del__ = lambda self: None
num_vector_swigregister = _regression.num_vector_swigregister
num_vector_swigregister(num_vector)

class idx_vector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, idx_vector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, idx_vector, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _regression.idx_vector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _regression.idx_vector___nonzero__(self)

    def __bool__(self):
        return _regression.idx_vector___bool__(self)

    def __len__(self):
        return _regression.idx_vector___len__(self)

    def __getslice__(self, i, j):
        return _regression.idx_vector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _regression.idx_vector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _regression.idx_vector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _regression.idx_vector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _regression.idx_vector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _regression.idx_vector___setitem__(self, *args)

    def pop(self):
        return _regression.idx_vector_pop(self)

    def append(self, x):
        return _regression.idx_vector_append(self, x)

    def empty(self):
        return _regression.idx_vector_empty(self)

    def size(self):
        return _regression.idx_vector_size(self)

    def swap(self, v):
        return _regression.idx_vector_swap(self, v)

    def begin(self):
        return _regression.idx_vector_begin(self)

    def end(self):
        return _regression.idx_vector_end(self)

    def rbegin(self):
        return _regression.idx_vector_rbegin(self)

    def rend(self):
        return _regression.idx_vector_rend(self)

    def clear(self):
        return _regression.idx_vector_clear(self)

    def get_allocator(self):
        return _regression.idx_vector_get_allocator(self)

    def pop_back(self):
        return _regression.idx_vector_pop_back(self)

    def erase(self, *args):
        return _regression.idx_vector_erase(self, *args)

    def __init__(self, *args):
        this = _regression.new_idx_vector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _regression.idx_vector_push_back(self, x)

    def front(self):
        return _regression.idx_vector_front(self)

    def back(self):
        return _regression.idx_vector_back(self)

    def assign(self, n, x):
        return _regression.idx_vector_assign(self, n, x)

    def resize(self, *args):
        return _regression.idx_vector_resize(self, *args)

    def insert(self, *args):
        return _regression.idx_vector_insert(self, *args)

    def reserve(self, n):
        return _regression.idx_vector_reserve(self, n)

    def capacity(self):
        return _regression.idx_vector_capacity(self)
    __swig_destroy__ = _regression.delete_idx_vector
    __del__ = lambda self: None
idx_vector_swigregister = _regression.idx_vector_swigregister
idx_vector_swigregister(idx_vector)

class num_vector_vector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, num_vector_vector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, num_vector_vector, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _regression.num_vector_vector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _regression.num_vector_vector___nonzero__(self)

    def __bool__(self):
        return _regression.num_vector_vector___bool__(self)

    def __len__(self):
        return _regression.num_vector_vector___len__(self)

    def __getslice__(self, i, j):
        return _regression.num_vector_vector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _regression.num_vector_vector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _regression.num_vector_vector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _regression.num_vector_vector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _regression.num_vector_vector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _regression.num_vector_vector___setitem__(self, *args)

    def pop(self):
        return _regression.num_vector_vector_pop(self)

    def append(self, x):
        return _regression.num_vector_vector_append(self, x)

    def empty(self):
        return _regression.num_vector_vector_empty(self)

    def size(self):
        return _regression.num_vector_vector_size(self)

    def swap(self, v):
        return _regression.num_vector_vector_swap(self, v)

    def begin(self):
        return _regression.num_vector_vector_begin(self)

    def end(self):
        return _regression.num_vector_vector_end(self)

    def rbegin(self):
        return _regression.num_vector_vector_rbegin(self)

    def rend(self):
        return _regression.num_vector_vector_rend(self)

    def clear(self):
        return _regression.num_vector_vector_clear(self)

    def get_allocator(self):
        return _regression.num_vector_vector_get_allocator(self)

    def pop_back(self):
        return _regression.num_vector_vector_pop_back(self)

    def erase(self, *args):
        return _regression.num_vector_vector_erase(self, *args)

    def __init__(self, *args):
        this = _regression.new_num_vector_vector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _regression.num_vector_vector_push_back(self, x)

    def front(self):
        return _regression.num_vector_vector_front(self)

    def back(self):
        return _regression.num_vector_vector_back(self)

    def assign(self, n, x):
        return _regression.num_vector_vector_assign(self, n, x)

    def resize(self, *args):
        return _regression.num_vector_vector_resize(self, *args)

    def insert(self, *args):
        return _regression.num_vector_vector_insert(self, *args)

    def reserve(self, n):
        return _regression.num_vector_vector_reserve(self, n)

    def capacity(self):
        return _regression.num_vector_vector_capacity(self)
    __swig_destroy__ = _regression.delete_num_vector_vector
    __del__ = lambda self: None
num_vector_vector_swigregister = _regression.num_vector_vector_swigregister
num_vector_vector_swigregister(num_vector_vector)

class num_vector_vector_vector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, num_vector_vector_vector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, num_vector_vector_vector, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _regression.num_vector_vector_vector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _regression.num_vector_vector_vector___nonzero__(self)

    def __bool__(self):
        return _regression.num_vector_vector_vector___bool__(self)

    def __len__(self):
        return _regression.num_vector_vector_vector___len__(self)

    def __getslice__(self, i, j):
        return _regression.num_vector_vector_vector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _regression.num_vector_vector_vector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _regression.num_vector_vector_vector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _regression.num_vector_vector_vector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _regression.num_vector_vector_vector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _regression.num_vector_vector_vector___setitem__(self, *args)

    def pop(self):
        return _regression.num_vector_vector_vector_pop(self)

    def append(self, x):
        return _regression.num_vector_vector_vector_append(self, x)

    def empty(self):
        return _regression.num_vector_vector_vector_empty(self)

    def size(self):
        return _regression.num_vector_vector_vector_size(self)

    def swap(self, v):
        return _regression.num_vector_vector_vector_swap(self, v)

    def begin(self):
        return _regression.num_vector_vector_vector_begin(self)

    def end(self):
        return _regression.num_vector_vector_vector_end(self)

    def rbegin(self):
        return _regression.num_vector_vector_vector_rbegin(self)

    def rend(self):
        return _regression.num_vector_vector_vector_rend(self)

    def clear(self):
        return _regression.num_vector_vector_vector_clear(self)

    def get_allocator(self):
        return _regression.num_vector_vector_vector_get_allocator(self)

    def pop_back(self):
        return _regression.num_vector_vector_vector_pop_back(self)

    def erase(self, *args):
        return _regression.num_vector_vector_vector_erase(self, *args)

    def __init__(self, *args):
        this = _regression.new_num_vector_vector_vector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _regression.num_vector_vector_vector_push_back(self, x)

    def front(self):
        return _regression.num_vector_vector_vector_front(self)

    def back(self):
        return _regression.num_vector_vector_vector_back(self)

    def assign(self, n, x):
        return _regression.num_vector_vector_vector_assign(self, n, x)

    def resize(self, *args):
        return _regression.num_vector_vector_vector_resize(self, *args)

    def insert(self, *args):
        return _regression.num_vector_vector_vector_insert(self, *args)

    def reserve(self, n):
        return _regression.num_vector_vector_vector_reserve(self, n)

    def capacity(self):
        return _regression.num_vector_vector_vector_capacity(self)
    __swig_destroy__ = _regression.delete_num_vector_vector_vector
    __del__ = lambda self: None
num_vector_vector_vector_swigregister = _regression.num_vector_vector_vector_swigregister
num_vector_vector_vector_swigregister(num_vector_vector_vector)

class num_num_pair(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, num_num_pair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, num_num_pair, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _regression.new_num_num_pair(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_setmethods__["first"] = _regression.num_num_pair_first_set
    __swig_getmethods__["first"] = _regression.num_num_pair_first_get
    if _newclass:
        first = _swig_property(_regression.num_num_pair_first_get, _regression.num_num_pair_first_set)
    __swig_setmethods__["second"] = _regression.num_num_pair_second_set
    __swig_getmethods__["second"] = _regression.num_num_pair_second_get
    if _newclass:
        second = _swig_property(_regression.num_num_pair_second_get, _regression.num_num_pair_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _regression.delete_num_num_pair
    __del__ = lambda self: None
num_num_pair_swigregister = _regression.num_num_pair_swigregister
num_num_pair_swigregister(num_num_pair)

class data_base(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, data_base, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, data_base, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _regression.delete_data_base
    __del__ = lambda self: None

    def feature(self, feature_index, sample_index):
        return _regression.data_base_feature(self, feature_index, sample_index)

    def features(self, feature_index, sample_indices):
        return _regression.data_base_features(self, feature_index, sample_indices)

    def response(self, sample_index):
        return _regression.data_base_response(self, sample_index)

    def weight(self, sample_index):
        return _regression.data_base_weight(self, sample_index)

    def add_data_point(self, features, response, weight):
        return _regression.data_base_add_data_point(self, features, response, weight)

    def retrieve_data_point(self, index):
        return _regression.data_base_retrieve_data_point(self, index)

    def get_type_of_feature(self, feature_index):
        return _regression.data_base_get_type_of_feature(self, feature_index)

    def get_type_of_response(self):
        return _regression.data_base_get_type_of_response(self)

    def set_type_of_feature(self, feature_index, feature_type):
        return _regression.data_base_set_type_of_feature(self, feature_index, feature_type)

    def set_type_of_response(self, response_type):
        return _regression.data_base_set_type_of_response(self, response_type)

    def set_bounds_of_feature(self, feature_index, min, max):
        return _regression.data_base_set_bounds_of_feature(self, feature_index, min, max)

    def get_bounds_of_feature(self, feature_index):
        return _regression.data_base_get_bounds_of_feature(self, feature_index)

    def num_features(self):
        return _regression.data_base_num_features(self)

    def num_data_points(self):
        return _regression.data_base_num_data_points(self)
data_base_swigregister = _regression.data_base_swigregister
data_base_swigregister(data_base)

class default_data_container(data_base):
    __swig_setmethods__ = {}
    for _s in [data_base]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, default_data_container, name, value)
    __swig_getmethods__ = {}
    for _s in [data_base]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, default_data_container, name)
    __repr__ = _swig_repr

    def __init__(self, num_f):
        this = _regression.new_default_data_container(num_f)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def init_protected(self, num_f):
        return _regression.default_data_container_init_protected(self, num_f)

    def feature(self, feature_index, sample_index):
        return _regression.default_data_container_feature(self, feature_index, sample_index)

    def features(self, feature_index, sample_indices):
        return _regression.default_data_container_features(self, feature_index, sample_indices)

    def response(self, sample_index):
        return _regression.default_data_container_response(self, sample_index)

    def add_data_point(self, features, response, weight=1):
        return _regression.default_data_container_add_data_point(self, features, response, weight)

    def retrieve_data_point(self, index):
        return _regression.default_data_container_retrieve_data_point(self, index)

    def weight(self, sample_index):
        return _regression.default_data_container_weight(self, sample_index)

    def get_type_of_feature(self, feature_index):
        return _regression.default_data_container_get_type_of_feature(self, feature_index)

    def set_type_of_feature(self, index, type):
        return _regression.default_data_container_set_type_of_feature(self, index, type)

    def num_features(self):
        return _regression.default_data_container_num_features(self)

    def num_data_points(self):
        return _regression.default_data_container_num_data_points(self)

    def get_type_of_response(self):
        return _regression.default_data_container_get_type_of_response(self)

    def set_type_of_response(self, resp_t):
        return _regression.default_data_container_set_type_of_response(self, resp_t)

    def set_bounds_of_feature(self, feature_index, min, max):
        return _regression.default_data_container_set_bounds_of_feature(self, feature_index, min, max)

    def get_bounds_of_feature(self, feature_index):
        return _regression.default_data_container_get_bounds_of_feature(self, feature_index)

    def get_min_max_of_feature(self, feature_index):
        return _regression.default_data_container_get_min_max_of_feature(self, feature_index)

    def guess_bounds_from_data(self):
        return _regression.default_data_container_guess_bounds_from_data(self)

    def import_csv_files(self, *args):
        return _regression.default_data_container_import_csv_files(self, *args)

    def check_consistency(self):
        return _regression.default_data_container_check_consistency(self)

    def print_data(self):
        return _regression.default_data_container_print_data(self)
    __swig_destroy__ = _regression.delete_default_data_container
    __del__ = lambda self: None
default_data_container_swigregister = _regression.default_data_container_swigregister
default_data_container_swigregister(default_data_container)

class tree_opts(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, tree_opts, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, tree_opts, name)
    __repr__ = _swig_repr
    __swig_setmethods__["max_features"] = _regression.tree_opts_max_features_set
    __swig_getmethods__["max_features"] = _regression.tree_opts_max_features_get
    if _newclass:
        max_features = _swig_property(_regression.tree_opts_max_features_get, _regression.tree_opts_max_features_set)
    __swig_setmethods__["max_depth"] = _regression.tree_opts_max_depth_set
    __swig_getmethods__["max_depth"] = _regression.tree_opts_max_depth_get
    if _newclass:
        max_depth = _swig_property(_regression.tree_opts_max_depth_get, _regression.tree_opts_max_depth_set)
    __swig_setmethods__["min_samples_to_split"] = _regression.tree_opts_min_samples_to_split_set
    __swig_getmethods__["min_samples_to_split"] = _regression.tree_opts_min_samples_to_split_get
    if _newclass:
        min_samples_to_split = _swig_property(_regression.tree_opts_min_samples_to_split_get, _regression.tree_opts_min_samples_to_split_set)
    __swig_setmethods__["min_samples_in_leaf"] = _regression.tree_opts_min_samples_in_leaf_set
    __swig_getmethods__["min_samples_in_leaf"] = _regression.tree_opts_min_samples_in_leaf_get
    if _newclass:
        min_samples_in_leaf = _swig_property(_regression.tree_opts_min_samples_in_leaf_get, _regression.tree_opts_min_samples_in_leaf_set)
    __swig_setmethods__["min_weight_in_leaf"] = _regression.tree_opts_min_weight_in_leaf_set
    __swig_getmethods__["min_weight_in_leaf"] = _regression.tree_opts_min_weight_in_leaf_get
    if _newclass:
        min_weight_in_leaf = _swig_property(_regression.tree_opts_min_weight_in_leaf_get, _regression.tree_opts_min_weight_in_leaf_set)
    __swig_setmethods__["max_num_nodes"] = _regression.tree_opts_max_num_nodes_set
    __swig_getmethods__["max_num_nodes"] = _regression.tree_opts_max_num_nodes_get
    if _newclass:
        max_num_nodes = _swig_property(_regression.tree_opts_max_num_nodes_get, _regression.tree_opts_max_num_nodes_set)
    __swig_setmethods__["max_num_leaves"] = _regression.tree_opts_max_num_leaves_set
    __swig_getmethods__["max_num_leaves"] = _regression.tree_opts_max_num_leaves_get
    if _newclass:
        max_num_leaves = _swig_property(_regression.tree_opts_max_num_leaves_get, _regression.tree_opts_max_num_leaves_set)
    __swig_setmethods__["epsilon_purity"] = _regression.tree_opts_epsilon_purity_set
    __swig_getmethods__["epsilon_purity"] = _regression.tree_opts_epsilon_purity_get
    if _newclass:
        epsilon_purity = _swig_property(_regression.tree_opts_epsilon_purity_get, _regression.tree_opts_epsilon_purity_set)

    def set_default_values(self):
        return _regression.tree_opts_set_default_values(self)

    def __init__(self, *args):
        this = _regression.new_tree_opts(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def adjust_limits_to_data(self, data):
        return _regression.tree_opts_adjust_limits_to_data(self, data)
    __swig_destroy__ = _regression.delete_tree_opts
    __del__ = lambda self: None
tree_opts_swigregister = _regression.tree_opts_swigregister
tree_opts_swigregister(tree_opts)

class base_tree(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, base_tree, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, base_tree, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _regression.delete_base_tree
    __del__ = lambda self: None

    def fit(self, *args):
        return _regression.base_tree_fit(self, *args)

    def predict(self, feature_vector):
        return _regression.base_tree_predict(self, feature_vector)

    def leaf_entries(self, feature_vector):
        return _regression.base_tree_leaf_entries(self, feature_vector)

    def number_of_nodes(self):
        return _regression.base_tree_number_of_nodes(self)

    def number_of_leafs(self):
        return _regression.base_tree_number_of_leafs(self)

    def depth(self):
        return _regression.base_tree_depth(self)

    def save_latex_representation(self, filename):
        return _regression.base_tree_save_latex_representation(self, filename)
base_tree_swigregister = _regression.base_tree_swigregister
base_tree_swigregister(base_tree)

class binary_full_tree_rss(base_tree):
    __swig_setmethods__ = {}
    for _s in [base_tree]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, binary_full_tree_rss, name, value)
    __swig_getmethods__ = {}
    for _s in [base_tree]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, binary_full_tree_rss, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _regression.new_binary_full_tree_rss()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _regression.delete_binary_full_tree_rss
    __del__ = lambda self: None

    def fit(self, data, tree_opts, sample_weights, rng):
        return _regression.binary_full_tree_rss_fit(self, data, tree_opts, sample_weights, rng)

    def find_leaf_index(self, feature_vector):
        return _regression.binary_full_tree_rss_find_leaf_index(self, feature_vector)

    def get_leaf(self, feature_vector):
        return _regression.binary_full_tree_rss_get_leaf(self, feature_vector)

    def leaf_entries(self, feature_vector):
        return _regression.binary_full_tree_rss_leaf_entries(self, feature_vector)

    def leaf_statistic(self, feature_vector):
        return _regression.binary_full_tree_rss_leaf_statistic(self, feature_vector)

    def predict(self, feature_vector):
        return _regression.binary_full_tree_rss_predict(self, feature_vector)

    def marginalized_mean_prediction(self, feature_vector, node_index=0):
        return _regression.binary_full_tree_rss_marginalized_mean_prediction(self, feature_vector, node_index)

    def number_of_nodes(self):
        return _regression.binary_full_tree_rss_number_of_nodes(self)

    def number_of_leafs(self):
        return _regression.binary_full_tree_rss_number_of_leafs(self)

    def depth(self):
        return _regression.binary_full_tree_rss_depth(self)

    def partition_recursor(self, the_partition, subspace, node_index):
        return _regression.binary_full_tree_rss_partition_recursor(self, the_partition, subspace, node_index)

    def partition(self, pcs):
        return _regression.binary_full_tree_rss_partition(self, pcs)

    def total_weight_in_subtree(self, node_index):
        return _regression.binary_full_tree_rss_total_weight_in_subtree(self, node_index)

    def check_split_fractions(self, epsilon=1e-6):
        return _regression.binary_full_tree_rss_check_split_fractions(self, epsilon)

    def pseudo_update(self, features, response, weight):
        return _regression.binary_full_tree_rss_pseudo_update(self, features, response, weight)

    def pseudo_downdate(self, features, response, weight):
        return _regression.binary_full_tree_rss_pseudo_downdate(self, features, response, weight)

    def print_info(self):
        return _regression.binary_full_tree_rss_print_info(self)

    def save_latex_representation(self, filename):
        return _regression.binary_full_tree_rss_save_latex_representation(self, filename)
binary_full_tree_rss_swigregister = _regression.binary_full_tree_rss_swigregister
binary_full_tree_rss_swigregister(binary_full_tree_rss)

class forest_opts(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, forest_opts, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, forest_opts, name)
    __repr__ = _swig_repr
    __swig_setmethods__["num_trees"] = _regression.forest_opts_num_trees_set
    __swig_getmethods__["num_trees"] = _regression.forest_opts_num_trees_get
    if _newclass:
        num_trees = _swig_property(_regression.forest_opts_num_trees_get, _regression.forest_opts_num_trees_set)
    __swig_setmethods__["num_data_points_per_tree"] = _regression.forest_opts_num_data_points_per_tree_set
    __swig_getmethods__["num_data_points_per_tree"] = _regression.forest_opts_num_data_points_per_tree_get
    if _newclass:
        num_data_points_per_tree = _swig_property(_regression.forest_opts_num_data_points_per_tree_get, _regression.forest_opts_num_data_points_per_tree_set)
    __swig_setmethods__["do_bootstrapping"] = _regression.forest_opts_do_bootstrapping_set
    __swig_getmethods__["do_bootstrapping"] = _regression.forest_opts_do_bootstrapping_get
    if _newclass:
        do_bootstrapping = _swig_property(_regression.forest_opts_do_bootstrapping_get, _regression.forest_opts_do_bootstrapping_set)
    __swig_setmethods__["compute_oob_error"] = _regression.forest_opts_compute_oob_error_set
    __swig_getmethods__["compute_oob_error"] = _regression.forest_opts_compute_oob_error_get
    if _newclass:
        compute_oob_error = _swig_property(_regression.forest_opts_compute_oob_error_get, _regression.forest_opts_compute_oob_error_set)
    __swig_setmethods__["tree_opts"] = _regression.forest_opts_tree_opts_set
    __swig_getmethods__["tree_opts"] = _regression.forest_opts_tree_opts_get
    if _newclass:
        tree_opts = _swig_property(_regression.forest_opts_tree_opts_get, _regression.forest_opts_tree_opts_set)

    def set_default_values(self):
        return _regression.forest_opts_set_default_values(self)

    def adjust_limits_to_data(self, data):
        return _regression.forest_opts_adjust_limits_to_data(self, data)

    def __init__(self, *args):
        this = _regression.new_forest_opts(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _regression.delete_forest_opts
    __del__ = lambda self: None
forest_opts_swigregister = _regression.forest_opts_swigregister
forest_opts_swigregister(forest_opts)

class binary_rss_forest(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, binary_rss_forest, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, binary_rss_forest, name)
    __repr__ = _swig_repr
    __swig_setmethods__["options"] = _regression.binary_rss_forest_options_set
    __swig_getmethods__["options"] = _regression.binary_rss_forest_options_get
    if _newclass:
        options = _swig_property(_regression.binary_rss_forest_options_get, _regression.binary_rss_forest_options_set)

    def __init__(self, *args):
        this = _regression.new_binary_rss_forest(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _regression.delete_binary_rss_forest
    __del__ = lambda self: None

    def fit(self, data, rng):
        return _regression.binary_rss_forest_fit(self, data, rng)

    def predict(self, feature_vector):
        return _regression.binary_rss_forest_predict(self, feature_vector)

    def predict_mean_var(self, feature_vector, weighted_data=False):
        return _regression.binary_rss_forest_predict_mean_var(self, feature_vector, weighted_data)

    def all_leaf_values(self, feature_vector):
        return _regression.binary_rss_forest_all_leaf_values(self, feature_vector)

    def pseudo_update(self, features, response, weight):
        return _regression.binary_rss_forest_pseudo_update(self, features, response, weight)

    def pseudo_downdate(self, features, response, weight):
        return _regression.binary_rss_forest_pseudo_downdate(self, features, response, weight)

    def out_of_bag_error(self):
        return _regression.binary_rss_forest_out_of_bag_error(self)

    def save_to_binary_file(self, filename):
        return _regression.binary_rss_forest_save_to_binary_file(self, filename)

    def load_from_binary_file(self, filename):
        return _regression.binary_rss_forest_load_from_binary_file(self, filename)

    def ascii_string_representation(self):
        return _regression.binary_rss_forest_ascii_string_representation(self)

    def load_from_ascii_string(self, str):
        return _regression.binary_rss_forest_load_from_ascii_string(self, str)

    def save_latex_representation(self, filename_template):
        return _regression.binary_rss_forest_save_latex_representation(self, filename_template)

    def print_info(self):
        return _regression.binary_rss_forest_print_info(self)

    def num_trees(self):
        return _regression.binary_rss_forest_num_trees(self)

    def __getstate__(self):
    	d = {}
    	d['str_representation'] = self.ascii_string_representation()
    	return (d)

    def __setstate__(self, sState):
    	self.__init__()
    	self.load_from_ascii_string(sState['str_representation'])

binary_rss_forest_swigregister = _regression.binary_rss_forest_swigregister
binary_rss_forest_swigregister(binary_rss_forest)

class qr_forest(binary_rss_forest):
    __swig_setmethods__ = {}
    for _s in [binary_rss_forest]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, qr_forest, name, value)
    __swig_getmethods__ = {}
    for _s in [binary_rss_forest]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, qr_forest, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _regression.new_qr_forest(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _regression.delete_qr_forest
    __del__ = lambda self: None

    def predict_quantiles(self, feature_vector, quantiles):
        return _regression.qr_forest_predict_quantiles(self, feature_vector, quantiles)
qr_forest_swigregister = _regression.qr_forest_swigregister
qr_forest_swigregister(qr_forest)

class fanova_forest_prototype(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, fanova_forest_prototype, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, fanova_forest_prototype, name)
    __repr__ = _swig_repr
    __swig_setmethods__["options"] = _regression.fanova_forest_prototype_options_set
    __swig_getmethods__["options"] = _regression.fanova_forest_prototype_options_get
    if _newclass:
        options = _swig_property(_regression.fanova_forest_prototype_options_get, _regression.fanova_forest_prototype_options_set)

    def __init__(self, *args):
        this = _regression.new_fanova_forest_prototype(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _regression.delete_fanova_forest_prototype
    __del__ = lambda self: None

    def fit(self, data, rng):
        return _regression.fanova_forest_prototype_fit(self, data, rng)

    def predict(self, feature_vector):
        return _regression.fanova_forest_prototype_predict(self, feature_vector)

    def predict_mean_var(self, feature_vector, weighted_data=False):
        return _regression.fanova_forest_prototype_predict_mean_var(self, feature_vector, weighted_data)

    def all_leaf_values(self, feature_vector):
        return _regression.fanova_forest_prototype_all_leaf_values(self, feature_vector)

    def pseudo_update(self, features, response, weight):
        return _regression.fanova_forest_prototype_pseudo_update(self, features, response, weight)

    def pseudo_downdate(self, features, response, weight):
        return _regression.fanova_forest_prototype_pseudo_downdate(self, features, response, weight)

    def out_of_bag_error(self):
        return _regression.fanova_forest_prototype_out_of_bag_error(self)

    def save_to_binary_file(self, filename):
        return _regression.fanova_forest_prototype_save_to_binary_file(self, filename)

    def load_from_binary_file(self, filename):
        return _regression.fanova_forest_prototype_load_from_binary_file(self, filename)

    def ascii_string_representation(self):
        return _regression.fanova_forest_prototype_ascii_string_representation(self)

    def load_from_ascii_string(self, str):
        return _regression.fanova_forest_prototype_load_from_ascii_string(self, str)

    def save_latex_representation(self, filename_template):
        return _regression.fanova_forest_prototype_save_latex_representation(self, filename_template)

    def print_info(self):
        return _regression.fanova_forest_prototype_print_info(self)

    def num_trees(self):
        return _regression.fanova_forest_prototype_num_trees(self)
fanova_forest_prototype_swigregister = _regression.fanova_forest_prototype_swigregister
fanova_forest_prototype_swigregister(fanova_forest_prototype)

class fanova_forest(fanova_forest_prototype):
    __swig_setmethods__ = {}
    for _s in [fanova_forest_prototype]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, fanova_forest, name, value)
    __swig_getmethods__ = {}
    for _s in [fanova_forest_prototype]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, fanova_forest, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _regression.new_fanova_forest(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _regression.delete_fanova_forest
    __del__ = lambda self: None

    def fit(self, data, rng):
        return _regression.fanova_forest_fit(self, data, rng)

    def set_cutoffs(self, lower, upper):
        return _regression.fanova_forest_set_cutoffs(self, lower, upper)

    def get_cutoffs(self):
        return _regression.fanova_forest_get_cutoffs(self)

    def precompute_marginals(self):
        return _regression.fanova_forest_precompute_marginals(self)

    def marginal_mean_prediction(self, feature_vector):
        return _regression.fanova_forest_marginal_mean_prediction(self, feature_vector)

    def marginal_mean_variance_prediction(self, feature_vector):
        return _regression.fanova_forest_marginal_mean_variance_prediction(self, feature_vector)

    def marginal_prediction_stat_of_tree(self, tree_index, feature_vector):
        return _regression.fanova_forest_marginal_prediction_stat_of_tree(self, tree_index, feature_vector)

    def get_trees_total_variances(self):
        return _regression.fanova_forest_get_trees_total_variances(self)

    def all_split_values(self):
        return _regression.fanova_forest_all_split_values(self)
fanova_forest_swigregister = _regression.fanova_forest_swigregister
fanova_forest_swigregister(fanova_forest)

# This file is compatible with both classic and new-style classes.


