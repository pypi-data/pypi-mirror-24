"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = require("react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _Observable = require("rxjs/Observable");

require("rxjs/add/observable/of");

require("rxjs/add/observable/fromEvent");

require("rxjs/add/operator/switchMap");

var _codemirror = require("./codemirror");

var _codemirror2 = _interopRequireDefault(_codemirror);

var _immutable = require("immutable");

var _transforms = require("@nteract/transforms");

var _excludedIntelliSenseKeys = require("./excludedIntelliSenseKeys");

var _excludedIntelliSenseKeys2 = _interopRequireDefault(_excludedIntelliSenseKeys);

var _complete = require("./complete");

var _tooltip = require("./tooltip");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
/* eslint-disable class-methods-use-this */


var CodeMirrorWrapper = function CodeMirrorWrapper(EditorView) {
  var customOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  return function (_PureComponent) {
    _inherits(CodeMirrorEditor, _PureComponent);

    function CodeMirrorEditor() {
      _classCallCheck(this, CodeMirrorEditor);

      var _this = _possibleConstructorReturn(this, (CodeMirrorEditor.__proto__ || Object.getPrototypeOf(CodeMirrorEditor)).call(this));

      _this.hint = _this.completions.bind(_this);
      _this.tips = _this.tips.bind(_this);
      _this.hint.async = true;
      return _this;
    }

    _createClass(CodeMirrorEditor, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        var _props = this.props,
            editorFocused = _props.editorFocused,
            executionState = _props.executionState,
            focusAbove = _props.focusAbove,
            focusBelow = _props.focusBelow;


        require("codemirror/addon/hint/show-hint");
        require("codemirror/addon/hint/anyword-hint");
        require("codemirror/addon/search/search");
        require("codemirror/addon/search/searchcursor");
        require("codemirror/addon/edit/matchbrackets");
        require("codemirror/addon/edit/closebrackets");
        require("codemirror/addon/dialog/dialog");
        require("codemirror/addon/comment/comment.js");
        require("codemirror/mode/python/python");
        require("codemirror/mode/ruby/ruby");
        require("codemirror/mode/javascript/javascript");
        require("codemirror/mode/css/css");
        require("codemirror/mode/julia/julia");
        require("codemirror/mode/r/r");
        require("codemirror/mode/clike/clike");
        require("codemirror/mode/shell/shell");
        require("codemirror/mode/sql/sql");
        require("codemirror/mode/markdown/markdown");
        require("codemirror/mode/gfm/gfm");

        require("./codemirror-ipython");

        var cm = this.codemirror.getCodeMirror();

        // On first load, if focused, set codemirror to focus
        if (editorFocused) {
          this.codemirror.focus();
        }

        cm.on("topBoundary", focusAbove);
        cm.on("bottomBoundary", focusBelow);

        var keyupEvents = _Observable.Observable.fromEvent(cm, "keyup", function (editor, ev) {
          return {
            editor: editor,
            ev: ev
          };
        });

        keyupEvents.switchMap(function (i) {
          return _Observable.Observable.of(i);
        }).subscribe(function (_ref) {
          var editor = _ref.editor,
              ev = _ref.ev;

          var cursor = editor.getDoc().getCursor();
          var token = editor.getTokenAt(cursor);

          if (!editor.state.completionActive && !_excludedIntelliSenseKeys2.default[(ev.keyCode || ev.which).toString()] && (token.type === "tag" || token.type === "variable" || token.string === " " || token.string === "<" || token.string === "/") && executionState === "idle") {
            editor.execCommand("autocomplete", { completeSingle: false });
          }
        });
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps) {
        var cm = this.codemirror.getCodeMirror();
        var _props2 = this.props,
            cursorBlinkRate = _props2.cursorBlinkRate,
            editorFocused = _props2.editorFocused,
            theme = _props2.theme;


        if (prevProps.theme !== theme) {
          cm.refresh();
        }

        if (prevProps.editorFocused !== editorFocused) {
          editorFocused ? this.codemirror.focus() : cm.getInputField().blur();
        }

        if (prevProps.cursorBlinkRate !== cursorBlinkRate) {
          cm.setOption("cursorBlinkRate", cursorBlinkRate);
          if (editorFocused) {
            // code mirror doesn't change the blink rate immediately, we have to
            // move the cursor, or unfocus and refocus the editor to get the blink
            // rate to update - so here we do that (unfocus and refocus)
            cm.getInputField().blur();
            cm.focus();
          }
        }
      }
    }, {
      key: "completions",
      value: function completions(editor, callback) {
        var _props3 = this.props,
            completion = _props3.completion,
            channels = _props3.channels;

        if (completion) {
          (0, _complete.codeComplete)(channels, editor).subscribe(callback);
        }
      }
    }, {
      key: "tips",
      value: function tips(editor) {
        var _props4 = this.props,
            tip = _props4.tip,
            channels = _props4.channels;

        var currentTip = document.getElementById("cl");
        var body = document.body;
        if (currentTip && body != null) {
          body.removeChild(currentTip);
          editor.setSize("auto", "auto");
          return;
        }
        if (tip) {
          (0, _tooltip.tool)(channels, editor).subscribe(function (resp) {
            var bundle = (0, _immutable.Map)(resp.dict);
            if (bundle.size === 0) {
              return;
            }
            var mimetype = "text/plain";
            // $FlowFixMe: until transforms refactored for new export interface GH #1488
            var Transform = _transforms.transforms.get(mimetype);
            var node = document.createElement("div");
            node.className = "CodeMirror-hint tip";
            node.id = "cl";
            _reactDom2.default.render(_react2.default.createElement(Transform, { data: bundle.get(mimetype) }), node);
            var node2 = document.createElement("button");
            node2.className = "bt";
            node2.id = "btnid";
            node2.textContent = "\u2715";
            node2.style.fontSize = "11.5px";
            node.appendChild(node2);
            node2.onclick = function removeButton() {
              this.parentNode.parentNode.removeChild(this.parentNode);
              return false;
            };
            editor.addWidget({ line: editor.getCursor().line, ch: 0 }, node, true);
            var x = document.getElementById("cl");
            if (x != null && body != null) {
              var pos = x.getBoundingClientRect();
              body.appendChild(x);
              x.style.top = pos.top + "px";
            }
          });
        }
      }
    }, {
      key: "getCodeMirrorOptions",
      value: function getCodeMirrorOptions(_ref2) {
        var cursorBlinkRate = _ref2.cursorBlinkRate,
            language = _ref2.language;

        return _extends({
          autoCloseBrackets: true,
          mode: language || "python",
          lineNumbers: false,
          lineWrapping: true,
          matchBrackets: true,
          theme: "composition",
          autofocus: false,
          hintOptions: {
            hint: this.hint,
            completeSingle: false, // In automatic autocomplete mode we don't want override
            extraKeys: {
              Right: _complete.pick
            }
          },
          extraKeys: {
            "Ctrl-Space": "autocomplete",
            Tab: this.executeTab,
            "Shift-Tab": function ShiftTab(editor) {
              return editor.execCommand("indentLess");
            },
            Up: this.goLineUpOrEmit,
            Down: this.goLineDownOrEmit,
            "Cmd-/": "toggleComment",
            "Ctrl-/": "toggleComment",
            "Cmd-.": this.tips,
            "Ctrl-.": this.tips
          },
          indentUnit: 4,
          cursorBlinkRate: cursorBlinkRate
        }, customOptions);
      }
    }, {
      key: "goLineDownOrEmit",
      value: function goLineDownOrEmit(editor) {
        var cursor = editor.getCursor();
        var lastLineNumber = editor.lastLine();
        var lastLine = editor.getLine(lastLineNumber);
        if (cursor.line === lastLineNumber && cursor.ch === lastLine.length && !editor.somethingSelected()) {
          var CM = require("codemirror");
          // $FlowFixMe: fix the flow definition for signal on a commonjs import
          CM.signal(editor, "bottomBoundary");
        } else {
          editor.execCommand("goLineDown");
        }
      }
    }, {
      key: "goLineUpOrEmit",
      value: function goLineUpOrEmit(editor) {
        var cursor = editor.getCursor();
        if (cursor.line === 0 && cursor.ch === 0 && !editor.somethingSelected()) {
          var CM = require("codemirror");
          // $FlowFixMe: fix the flow definition for signal on a commonjs import
          CM.signal(editor, "topBoundary");
        } else {
          editor.execCommand("goLineUp");
        }
      }
    }, {
      key: "executeTab",
      value: function executeTab(editor) {
        editor.somethingSelected() ? editor.execCommand("indentMore") : editor.execCommand("insertSoftTab");
      }
    }, {
      key: "render",
      value: function render() {
        var _this2 = this;

        var _props5 = this.props,
            input = _props5.input,
            onChange = _props5.onChange,
            onFocusChange = _props5.onFocusChange;

        var options = this.getCodeMirrorOptions(this.props);

        return _react2.default.createElement(
          EditorView,
          this.props,
          _react2.default.createElement(_codemirror2.default, {
            value: input,
            ref: function ref(el) {
              _this2.codemirror = el;
            },
            className: "cell_cm",
            options: options,
            onChange: onChange,
            onClick: function onClick() {
              return _this2.codemirror.focus();
            },
            onFocusChange: onFocusChange
          })
        );
      }
    }]);

    return CodeMirrorEditor;
  }(_react.PureComponent);
};

exports.default = CodeMirrorWrapper;