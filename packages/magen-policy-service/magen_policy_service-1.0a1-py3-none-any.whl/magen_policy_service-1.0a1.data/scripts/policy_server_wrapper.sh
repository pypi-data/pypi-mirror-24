set -o pipefail
set -u

PYTHON=python3

# POLICY COVERAGE MASTER_COMMENT
# basic sequence:
# - coverage run:    run tests, collect coverage information in .coverage file
# - coverage report: calculate coverage information
# - coverage html:   prepare html files that graphically what code is
#                    not being covered. (With browser, open
#                    coverage_html_report/index.html)
#
# Policy has wrinkles with "coverage run" due to the operational code
# being tested
# - in a separate policy_server.py process that pytest talks to over rest
#   (for most of the tests including policy_basic_test.py)
# - in policy modules imported into the pytest process
#   (for policy_events_test.py)
# Idea is to
# - collect policy code coverage information from _each_ process
# - _combine_ the coverage information
# - generate a single report showing the combined coverage information
# Mechnically:
# - execute both pytest and policy_server.py under "coverage run"
# - pytest exits first, generates its coverage information first.
#   Thus, it is thus is run without the --apend switch, to cause ovwriting
#   of any information in .coverage's from previous runs.
#   - separately, "--module" flag is needed for "coverage run" on pytest
#     (since pytest wants to be treated as imported)
# - policy_server.py exits second (due to signal) thus genarates its coverage
#   information second
#   Thus it is run _with_ the --append switch, so its coverage (of
#   policy modules) is comobined with the coverage generated by pytest
#   (running the tests in policy_events_test.py)
_COVERAGE_RUN="coverage run"
COVERAGE_RUN_PYTEST="$_COVERAGE_RUN --module"
COVERAGE_RUN_PS="$_COVERAGE_RUN --append"

PYTEST=pytest

progname=$(basename $0)

mode=
DATA_DIR_ARGS=
data_dir=
log_dir=../logs
MONGO_PORT_ARGS=
mongo_ip_port=


usage()
{
    cat <<USAGE
Usage: $progname -mode {operational|test} --data-dir <dir> [--mongo-ip-port <port>]

Description:
	Run policy server and location server, as appropriate for mode
USAGE

    exit $1
}

# extract pid for supplied tag
# tag is of form "[p]olicy_server" rather than just "policy_server"
# so grep command does not find itself.
get_pid()
{
    ps_tag=$1
    pid=$(ps aux | grep "/$ps_tag" | awk '{ print $2 }')
    echo $pid
}


#
# For macOS, compensate for non-support of wait's -n flag
# with a polling loop
#
wait_n_pidlist()
{
    OS=$(uname)
    case "$OS" in
    Darwin)
	while true; do
	    for pid in ${1+"$@"}; do
		kill -0 $pid
		if [ $? != 0 ]; then
		    return
		fi
	    done
	sleep 2
	done
	;;
    *)
	wait -n ${1+"$@"}
	;;
    esac
}

while [ $# != 0 ]; do
    case $1 in
    -mode)
	shift
	mode=$1
	;;
    --data-dir)
	shift
	data_dir=$1
	;;
    --log-dir)
	shift
	log_dir=$1
	;;
    --mongo-ip-port)
	shift
	mongo_ip_port=$1
	;;
    *)
	echo "$progname: FATAL: Unknown argument ($1)" >&2
	exit 1
	;;
    esac
    shift
done

case "$mode" in
operational)
    # valid mode
    if [ ! -z "$data_dir" ]; then
	DATA_DIR_ARGS="--data-dir $data_dir"
    fi
    ;;
test)
    # valid mode
    ;;
"")
    echo "$progname: FATAL: mode not specified" >&2
    usage 1
    ;;
*)
    echo "$progname: FATAL: Unknown mode ($mode)" >&2
    usage 1
    ;;
esac

if [ -n "$mongo_ip_port"  ]; then
    MONGO_PORT_ARGS="--mongo-ip-port $mongo_ip_port"
fi

case "$mode" in
operational)
    POLICY_LOG_DIR=$log_dir/policy_logs
    LOCATION_LOG_DIR=$log_dir/location_logs
    ;;
test)
    POLICY_LOG_DIR=$log_dir/policy_test_logs
    LOCATION_LOG_DIR=$log_dir/location_test_logs
    ;;
esac

policy_server_source=./policy_server/policy_server.py
if [ -f $policy_server_source ]; then
    ver=source    # source mounted, run source version
else
    ver=installed # source not mounted, run install version
fi

case $ver in
source)
    case $mode in
    operational)
	POLICY_CMD="${PYTHON} $policy_server_source"
	;;
    test)
	POLICY_CMD="${COVERAGE_RUN_PS} $policy_server_source"
	;;
    esac
    LOCATION_CMD="${PYTHON} ../magen_location/location_server/location_server.py"
    ;;
installed)
    POLICY_CMD=policy_server.py
    LOCATION_CMD=location_server.py
    ;;
*)
    echo "$progname: FATAL: Unknown version ($ver)" >&2
    usage 1
    ;;
esac
    
echo "%%%%%%%% POLICY CONTAINER ($mode mode, $ver version) STARTING at $(date) %%%%%%%%"

case $mode in
operational)
    echo "************  EXECUTING POLICY SERVICE ************"
    ${POLICY_CMD} \
	    --console-log-level debug \
	    $DATA_DIR_ARGS \
	    $MONGO_PORT_ARGS \
	    --log-dir $POLICY_LOG_DIR &
    ;;
test)
    echo " ==========  PRETEST CLEANING =========="
    rm -rf coverage_html_report
    coverage erase
    POLICY_PID=$(get_pid "[p]olicy_server.py")
    LOCATION_PID=$(get_pid "[l]ocation_server.py")
    if [ ! -z "$POLICY_PID" -o ! -z "$LOCATION_PID" ]; then
       echo "ERROR: server(s) already running: policy_pid: ${POLICY_PID:-none} , location_pid: ${LOCATION_PID:-none}"
       exit 1
    fi
    echo "************  EXECUTING POLICY SERVICE WITH COVERAGE ************"
    ${POLICY_CMD} \
	    --test \
	    $MONGO_PORT_ARGS \
	    --log-dir $POLICY_LOG_DIR &
    ;;
esac
policy_pid=$!

echo "************  EXECUTING LOCATION SERVICE ************"
sleep 1
case $mode in
operational)
    ${LOCATION_CMD} \
	    $MONGO_PORT_ARGS \
	    --console-log-level info \
	    --log-dir $LOCATION_LOG_DIR &
    ;;
test)
    ${LOCATION_CMD} \
	    --test \
	    $MONGO_PORT_ARGS \
	    --log-dir $LOCATION_LOG_DIR &
    ;;
esac
location_pid=$!

case $mode in
operational)
    # for operational, this script is primary job: leave script active until
    # servers exit, otherwise docker container will exit
    wait_n_pidlist $policy_pid $location_pid
    status=$?  # save first exiting proc's status for script exit status
    kill -0 $policy_pid 2> /dev/null
    if [ $? != 0 ]; then
       exited_proc="policy"
    else
       exited_proc="location"
    fi
    echo "************	EXITING POLICY CLUSTER (on $exited_proc service exit) ************"
    POLICY_PID=$(get_pid "[p]olicy_server.py")
    if [ ! -z "${POLICY_PID}" ]; then
	kill -9 ${POLICY_PID}
    fi
    LOCATION_PID=$(get_pid "[l]ocation_server.py")
    if [ ! -z "${LOCATION_PID}" ]; then
	kill -9 ${LOCATION_PID}
    fi
    exit $status
    ;;
test)
    # for test, this script exits to allow pytest to run
    sleep 2
    ${COVERAGE_RUN_PYTEST} ${PYTEST} tests
    pytest_res=$?
    POLICY_PID=$(get_pid "[p]olicy_server.py")
    LOCATION_PID=$(get_pid "[l]ocation_server.py")
    echo "************  CLEANING UP SERVICES (POLICY_PID:${POLICY_PID}, LOCATION_PID:${LOCATION_PID}) ************"
    # use kill -2 on module-under-test to collect coverage information
    if [ $pytest_res = 0 ]; then
	echo "************  TESTS PASSED: COLLECTING COVERAGE ************"
	ps_sig=2 # if tests succeeded, generate coverate
    else
	echo "************  TESTS FAILED: SKIPPING COVERAGE ************"
	ps_sig=9
    fi
    kill -$ps_sig ${POLICY_PID}
    # kill location before coverage generation to suppress periodic msgs
    kill -9 ${LOCATION_PID}
    if [ $pytest_res = 0 ]; then
	sleep 1
	coverage report
	coverage html
    fi
    exit $pytest_res
    ;;
esac
