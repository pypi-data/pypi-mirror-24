import argparse
import docker
import io
import json
import os
import requests
import shutil
import sys
import zipfile


##############################################################################################################
# constants
##############################################################################################################


PATH_PREFIX = '/collab'
INPUT_FILE_LOCATION = os.path.join(PATH_PREFIX, 'in.txt')
OUTPUT_FILE_LOCATION = os.path.join(PATH_PREFIX, 'out.txt')

_SOURCE_OF_TRUTH = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'TRUTH.txt')
_CONFIG_FILE = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'config.txt')
_DOCKER_EXAMPLE_NAME = 'fibonacci'
_DOCKER_EXAMPLE_PATH = os.path.join(os.path.dirname(os.path.abspath(__file__)), _DOCKER_EXAMPLE_NAME)
_truth = None
def _get_truth():
    """
    load constants from a file that is autogenerated from the outside when this module is compiled.
    This is a convenient way to share constants between different applications during development.
    Uses a cache.
    """
    global _truth
    if _truth is None:
        with open(_SOURCE_OF_TRUTH, 'r') as f:
            _truth = json.load(f)
    return _truth

def _get_server_url():
    """
    get a connection string that can be used to connect to the server
    """
    url = _get_truth()['server_url']
    return url

def _get_json_encoding_of_server():
    """
    get the type of encoding that the server uses for encoding JSON strings
    """
    url = _get_truth()['json_encoding']
    return url

def _get_docker_registry():
    """
    get the registry used to store Docker Images.
    """
    url = _get_truth()['docker_registry']
    return url


##############################################################################################################
# utilities
##############################################################################################################


def docker_connect():
    """
    connect to a Docker registry
    """
    client = docker.from_env()
    # TODO:
    # use _get_docker_registry() here
    #client = docker.DockerClient(base_url=_get_docker_registry())
    return client


def zipdir(path, zip_handle, includeEmptyDIr=True):
    """
    zip a directory
    """
    def get_relative_path(root, file):
        return os.path.relpath(os.path.join(root, file), os.path.join(path, '..'))
    empty_dirs = []
    for root, dirs, files in os.walk(path):
        empty_dirs.extend([dir for dir in dirs if os.listdir(os.path.join(root, dir)) == []])
        for file in files:
            zip_handle.write(os.path.join(root, file), get_relative_path(root, file))
        if includeEmptyDIr:
            for dir in empty_dirs:
                zif = zipfile.ZipInfo(get_relative_path(root, dir) + "/")
                zip_handle.writestr(zif, "")
        empty_dirs = []


##############################################################################################################
# main - initialize
##############################################################################################################


parser = argparse.ArgumentParser()
subparsers = parser.add_subparsers()

def require_authentication(subparser):
    subparser.add_argument('-e', '--email', default=None,
        help="the password of your Collab account. This can be skipped if you have already used the 'configure' command.")
    subparser.add_argument('-p', '--password', default=None,
        help="the password of your Collab account. This can be skipped if you have already used the 'configure' command.")

def check_if_credentials_are_configured(args):
    """
    if the arguments contain an email and password, return them.
    If not, check if there is a configuration file and use it.
    """
    if args.email is not None and args.password is not None:
        return
    if (0 if args.email is None else 1) + (0 if args.password is None else 1) == 1:
        raise ValueError("either both or neither of email and password must be specified.")
    if os.path.isfile(_CONFIG_FILE):
        with open(_CONFIG_FILE, 'r') as f:
            config = json.load(f)
            args.email = config['email']
            args.password = config['password']
    else:
        raise ValueError("email and password must be specified. Either use a configuration file for this or provide them as arguments. See --help for details.")


##############################################################################################################
# main - functions
##############################################################################################################


def configure(args):
    if args.delete:
        if os.path.isfile(_CONFIG_FILE):
            os.remove(_CONFIG_FILE)
            return
        else:
            raise ValueError("no config file exists.")
    if args.email is not None and args.password is not None:
        with open(_CONFIG_FILE, 'w') as f:
            config = {
                'email' : args.email,
                'password' : args.password,
            }
            json.dump(config, f)
        print("successfully created configuration file.")
    else:
        raise ValueError("both an email and a password must be specified.")

subparser = subparsers.add_parser('configure',
    help="""creates a configuration file to store your login credentials, so you don't have to specify them every time.
    Be aware that anyone who steals this configuration file will be able to log in with your credentials unless you delete the file again.""")
subparser.add_argument('-e', '--email', default=None,
    help="the password of your Collab account. This can be skipped if you have already used the 'configure' command.")
subparser.add_argument('-p', '--password', default=None,
    help="the password of your Collab account. This can be skipped if you have already used the 'configure' command.")
subparser.add_argument('-d', '--delete', action='store_true',
    help="delete the configuration file.")
subparser.set_defaults(func=configure)


def generate_example_program(args):
    dst = os.path.join(args.folder, _DOCKER_EXAMPLE_NAME)
    if os.path.exists(args.folder):
        raise ValueError("the specified path already exists: %s" % dst)
    shutil.copytree(_DOCKER_EXAMPLE_PATH, dst)
    # manually delete the pycache that gets created for some reason...
    cache = os.path.join(dst, '__pycache__')
    if os.path.exists(cache):
        shutil.rmtree(cache)


subparser = subparsers.add_parser('generate-example-program', help="creates an example program, as a tutorial what the files of a program for Collab should look like.")
subparser.add_argument('-f', '--folder', required=True, help="the path to the folder in which the example program will be generated.")
subparser.set_defaults(func=generate_example_program)


def upload_program(args):
    if args.quiet and args.verbose:
        raise ValueError("can't be both quiet and verbose at the same time")
    check_if_credentials_are_configured(args)
    folder = args.folder
    if folder is None:
        folder = os.getcwd()
    image_name = args.name
    program_description = args.description
    docker_user_name = "example_user" # TODO: use a real user name here
    full_image_name = "%s/%s" % (docker_user_name, image_name,)
    full_image_name_with_registry = "%s/%s/%s" % (_get_docker_registry(), docker_user_name, image_name,)
    #
    # get the description
    #
    descr_file_path = os.path.join(folder, 'DESCRIPTION.txt')
    if program_description is None:
        if os.path.isfile(descr_file_path):
            with open(descr_file_path, 'r') as f:
                program_description = f.read()
        else:
            program_description = "no description given."
    #
    # get miscellaneous arguments
    #
    max_execution_duration = args.max_execution_duration
    if max_execution_duration is None:
        max_execution_duration = _get_truth()['new_program_default_max_execution_duration']
    #
    # build the Docker image
    #
    # find out how many versions of the Image already exist, if any
    if not args.quiet:
        print("compiling Docker Image...")
    client = docker_connect()
    image = client.images.build(path=folder)
    #
    # if required, upload the source code as well
    #
    no_source_upload = args.no_source_upload
    files = {}
    if not no_source_upload:
        virtual_file = io.BytesIO()
        zip_handle = zipfile.ZipFile(virtual_file, 'w', zipfile.ZIP_DEFLATED)
        zipdir(folder, zip_handle)
        zip_handle.close()
        files['source_files_archive'] = virtual_file.getvalue()
    #
    # notify the Collab server
    # (and optionally upload the files)
    #
    if not args.quiet:
        print("contacting Collab server...")
    data = {
        'email' : args.email,
        'password' : args.password,
        'full_image_name_with_registry' : full_image_name_with_registry,
        'docker_user_name' : docker_user_name,
        'program_name' : image_name,
        'program_description' : program_description,
        'max_execution_duration' : max_execution_duration,
    }
    url = _get_server_url() + '/api/upload_program/'
    resp = requests.post(url, data=data, files=files)
    resp = json.loads(resp._content.decode(_get_json_encoding_of_server()))
    #
    # print the response received from the server
    #
    if 'error' in resp:
        print("error message from server:\n%s" % (resp['error'],))
        print("---\ncancelling upload.")
        return
    program_id = resp['id']
    program_name = resp['name']
    version = resp['version']
    response_text = resp['response_text']
    if args.verbose:
        print(response_text)
    #
    # Tag the Image with the right version number and push it to the registry server
    #
    # tag the image
    if not args.quiet:
        print("tagging and uploading Docker Image...")
    tag = "version-%d" % (version,)
    full_identifier = '%s:%s' % (full_image_name_with_registry, tag)
    # (tagging with this API apparently works by just building the Image again and relying on the cache to avoid actually rebuilding it)
    image = client.images.build(path=folder, tag=full_identifier)
    # push to the registry
    for line in client.images.push(full_image_name_with_registry, tag=tag, stream=True):
        msgs = [json.loads(a) for a in line.decode('utf-8').split('\n') if a != ""]
        for msg in msgs:
            if 'error' in msg:
                raise Exception(msg['error'])
            elif 'status' in msg:
                if args.verbose:
                    print("\t%s" % (msg['status'],))
    if not args.quiet:
        print("done. Created version %d of Program '%s' with id=%d, with Docker Image:\n%s" % (version, program_name, program_id, full_identifier,))

subparser = subparsers.add_parser('upload-program',
    help="""upload a program to the server, making it available for use by execution rules.
    Can be used for creating new programs, or updating existing ones.""")
subparser.add_argument('-f', '--folder', default=None,
    help="the path to the folder that should be uploaded. This should target the directory in which the Dockerfile is located. Defaults to the current directory.")
subparser.add_argument('-n', '--name', required=True,
    help="the name of the program. If an existing name is given, a new version of it will be created. Otherwise, a new program is created.")
subparser.add_argument('-d', '--description', default=None,
    help="a short description of the program. If none is given, defaults to the content of the file 'DESCRIPTION.txt' stored in the folder that is being uploaded, if one exists.")
subparser.add_argument('--max-execution-duration', type=float, default=None,
    help="the time, in seconds, that the program will be executed for before being quit by force, unless this is specified otherwise by whatever caused the program's execution. Defaults to %f" % (_get_truth()['new_program_default_max_execution_duration'],))
subparser.add_argument('--no-source-upload', action='store_true',
    help="whether or not to also upload the source files to the Collab server, to make them available for inspection.")
subparser.add_argument('-q', '--quiet', action='store_true',
    help="don't print anything to the console.")
subparser.add_argument('-v', '--verbose', action='store_true',
    help="print lots of extra information to the console.")
require_authentication(subparser)
subparser.set_defaults(func=upload_program)


def download_program(args):
    folder = args.folder
    if folder is None:
        folder = os.getcwd()
    id = args.identifier
    name = args.name
    version = args.version
    if id is None and name is None:
        raise ValueError("either the name or the ID of the program must be given.")
    if id is not None and name is not None:
        raise ValueError("only one out of the name and the ID of the program must be given, not both.")
    if name is not None and '#' in name:
        if version is not None:
            raise ValueError("don't specify the version both directly and indirectly (as part of the name). One of the two suffices.")
        tmp = name.split('#')
        name = tmp[0]
        version = tmp[1]
        if len(tmp) != 2:
            raise ValueError("invalid name format. Use either '<program_name>'' or '<program_nam>#<version>'.")
    if id is not None and version is not None:
        raise ValueError("don't specify a version along with an ID. IDs identify programs unambiguously. Only names are ambiguous and need clarification.")
    #
    # notify the Collab server
    #
    data = {}
    if name is not None:
        data['name'] = name
    if version is not None:
        data['version'] = int(version)
    if id is not None:
        data['id'] = int(id)
    url = _get_server_url() + '/api/download_program/'
    resp = requests.post(url, data=data)
    #
    # print the response received from the server
    #
    response_file = resp._content
    response_data = json.loads(resp.headers['additional_response_data'])
    if 'error' in response_data:
        print("error message from server:\n%s" % (response_data['error'],))
        return
    response_text = response_data['response_text']
    id = response_data['id']
    name = response_data['name']
    version = response_data['version']
    source_code_exists = response_data['source_code_exists']
    if not args.quiet:
        print(response_text)
    #
    # unzip the file, if there is one
    #
    if not args.quiet:
        print("retrieved program: id=%d, name='%s', version=%d" % (id, name, version,))
    if source_code_exists:
        if not args.quiet:
            print("unpacking files...")
        unzipped_path = os.path.join(folder, "%s-version-%d" % (name, version,))
        zip_ref = zipfile.ZipFile(io.BytesIO(response_file), 'r')
        zip_ref.extractall(unzipped_path)
        zip_ref.close()
        if not args.quiet:
            print("done.")
    else:
        if not args.quiet:
            print("no source code for this Program and version was made available.")

subparser = subparsers.add_parser('download-program',
    help="""download a program from the server.""")
subparser.add_argument('-f', '--folder', default=None,
    help="the path to the folder where the downloaded program should be placed. The folder containing the program will be put inside this folder. Defaults to the current directory.")
subparser.add_argument('-id', '--identifier', default=None,
    help="the ID of the program to download.")
subparser.add_argument('-n', '--name', default=None,
    help="""the name of the program to download. If no version is provided along with this, you get the latest version.
    The version can either be specified explicitly, through the --version tag, or by appending '#<version>' to the name.""")
subparser.add_argument('-v', '--version', default=None,
    help="the version of the program to download. This is only meaningful when combined with the program's name.")
subparser.add_argument('-q', '--quiet', action='store_true',
    help="don't print anything to the console.")
require_authentication(subparser)
subparser.set_defaults(func=download_program)


##############################################################################################################
# main - finalize
##############################################################################################################


def main():
    if len(sys.argv)==1:
        # if the program is called without arguments, print the help menu and exit
        parser.print_help()
        sys.exit(1)
    else:
        args = parser.parse_args()
        args.func(args)

if __name__ == '__main__':
    main()


