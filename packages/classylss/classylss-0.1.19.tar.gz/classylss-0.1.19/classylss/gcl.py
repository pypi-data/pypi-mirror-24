# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.10
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_gcl')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_gcl')
    _gcl = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_gcl', [dirname(__file__)])
        except ImportError:
            import _gcl
            return _gcl
        if fp is not None:
            try:
                _mod = imp.load_module('_gcl', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _gcl = swig_import_helper()
    del swig_import_helper
else:
    import _gcl
del _swig_python_version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _gcl.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self):
        return _gcl.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _gcl.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _gcl.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _gcl.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _gcl.SwigPyIterator_equal(self, x)

    def copy(self):
        return _gcl.SwigPyIterator_copy(self)

    def next(self):
        return _gcl.SwigPyIterator_next(self)

    def __next__(self):
        return _gcl.SwigPyIterator___next__(self)

    def previous(self):
        return _gcl.SwigPyIterator_previous(self)

    def advance(self, n):
        return _gcl.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _gcl.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _gcl.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _gcl.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _gcl.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _gcl.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _gcl.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _gcl.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class Constants(_object):
    """Proxy of C++ Constants class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Constants, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Constants, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    cm = _gcl.Constants_cm
    gram = _gcl.Constants_gram
    second = _gcl.Constants_second
    erg = _gcl.Constants_erg
    kelvin = _gcl.Constants_kelvin
    radian = _gcl.Constants_radian
    giga = _gcl.Constants_giga
    mega = _gcl.Constants_mega
    kilo = _gcl.Constants_kilo
    centi = _gcl.Constants_centi
    milli = _gcl.Constants_milli
    micro = _gcl.Constants_micro
    nano = _gcl.Constants_nano
    pico = _gcl.Constants_pico
    h_planck = _gcl.Constants_h_planck
    h_bar = _gcl.Constants_h_bar
    c_light = _gcl.Constants_c_light
    k_b = _gcl.Constants_k_b
    m_p = _gcl.Constants_m_p
    m_e = _gcl.Constants_m_e
    q_e = _gcl.Constants_q_e
    G = _gcl.Constants_G
    eV = _gcl.Constants_eV
    N_a = _gcl.Constants_N_a
    sigma_sb = _gcl.Constants_sigma_sb
    a_rad = _gcl.Constants_a_rad
    sigma_T = _gcl.Constants_sigma_T
    T_cmb = _gcl.Constants_T_cmb
    H_0 = _gcl.Constants_H_0
    a_0 = _gcl.Constants_a_0
    km = _gcl.Constants_km
    meter = _gcl.Constants_meter
    inch = _gcl.Constants_inch
    mm = _gcl.Constants_mm
    micron = _gcl.Constants_micron
    angstrom = _gcl.Constants_angstrom
    jansky = _gcl.Constants_jansky
    barn = _gcl.Constants_barn
    joule = _gcl.Constants_joule
    watt = _gcl.Constants_watt
    rydberg = _gcl.Constants_rydberg
    au = _gcl.Constants_au
    degree = _gcl.Constants_degree
    arcminute = _gcl.Constants_arcminute
    arcsecond = _gcl.Constants_arcsecond
    parsec = _gcl.Constants_parsec
    minute = _gcl.Constants_minute
    hour = _gcl.Constants_hour
    day = _gcl.Constants_day
    year = _gcl.Constants_year
    Mpc = _gcl.Constants_Mpc
    lyr = _gcl.Constants_lyr
    L_sun = _gcl.Constants_L_sun
    M_sun = _gcl.Constants_M_sun
    R_sun = _gcl.Constants_R_sun
    T_sun = _gcl.Constants_T_sun
    M_earth = _gcl.Constants_M_earth
    R_earth = _gcl.Constants_R_earth
    M_jupiter = _gcl.Constants_M_jupiter
    R_jupiter = _gcl.Constants_R_jupiter
Constants_swigregister = _gcl.Constants_swigregister
Constants_swigregister(Constants)


def TrapzIntegrate(x, y):
    """TrapzIntegrate(parray const & x, parray const & y) -> double"""
    return _gcl.TrapzIntegrate(x, y)

def SimpsIntegrate(x, y):
    """SimpsIntegrate(parray const & x, parray const & y) -> double"""
    return _gcl.SimpsIntegrate(x, y)
class IntegrationMethods(_object):
    """Proxy of C++ IntegrationMethods class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntegrationMethods, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntegrationMethods, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    FFTLOG = _gcl.IntegrationMethods_FFTLOG
    SIMPS = _gcl.IntegrationMethods_SIMPS
    TRAPZ = _gcl.IntegrationMethods_TRAPZ
IntegrationMethods_swigregister = _gcl.IntegrationMethods_swigregister
IntegrationMethods_swigregister(IntegrationMethods)


def pk_to_xi(*args, **kwargs):
    """pk_to_xi(int ell, parray const & k, parray const & pk, parray const & r, double smoothing=0.5, IntegrationMethods::Type method) -> parray"""
    return _gcl.pk_to_xi(*args, **kwargs)

def xi_to_pk(*args, **kwargs):
    """xi_to_pk(int ell, parray const & r, parray const & xi, parray const & k, double smoothing=0.005, IntegrationMethods::Type method) -> parray"""
    return _gcl.xi_to_pk(*args, **kwargs)
class VectorString(_object):
    """Proxy of C++ std::vector<(std::string)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorString, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VectorString, name)
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(VectorString self) -> SwigPyIterator"""
        return _gcl.VectorString_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(VectorString self) -> bool"""
        return _gcl.VectorString___nonzero__(self)


    def __bool__(self):
        """__bool__(VectorString self) -> bool"""
        return _gcl.VectorString___bool__(self)


    def __len__(self):
        """__len__(VectorString self) -> std::vector< std::string >::size_type"""
        return _gcl.VectorString___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(VectorString self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j) -> VectorString"""
        return _gcl.VectorString___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(VectorString self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j)
        __setslice__(VectorString self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j, VectorString v)
        """
        return _gcl.VectorString___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(VectorString self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j)"""
        return _gcl.VectorString___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(VectorString self, std::vector< std::string >::difference_type i)
        __delitem__(VectorString self, PySliceObject * slice)
        """
        return _gcl.VectorString___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(VectorString self, PySliceObject * slice) -> VectorString
        __getitem__(VectorString self, std::vector< std::string >::difference_type i) -> std::vector< std::string >::value_type const &
        """
        return _gcl.VectorString___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(VectorString self, PySliceObject * slice, VectorString v)
        __setitem__(VectorString self, PySliceObject * slice)
        __setitem__(VectorString self, std::vector< std::string >::difference_type i, std::vector< std::string >::value_type const & x)
        """
        return _gcl.VectorString___setitem__(self, *args)


    def pop(self):
        """pop(VectorString self) -> std::vector< std::string >::value_type"""
        return _gcl.VectorString_pop(self)


    def append(self, x):
        """append(VectorString self, std::vector< std::string >::value_type const & x)"""
        return _gcl.VectorString_append(self, x)


    def empty(self):
        """empty(VectorString self) -> bool"""
        return _gcl.VectorString_empty(self)


    def size(self):
        """size(VectorString self) -> std::vector< std::string >::size_type"""
        return _gcl.VectorString_size(self)


    def swap(self, v):
        """swap(VectorString self, VectorString v)"""
        return _gcl.VectorString_swap(self, v)


    def begin(self):
        """begin(VectorString self) -> std::vector< std::string >::iterator"""
        return _gcl.VectorString_begin(self)


    def end(self):
        """end(VectorString self) -> std::vector< std::string >::iterator"""
        return _gcl.VectorString_end(self)


    def rbegin(self):
        """rbegin(VectorString self) -> std::vector< std::string >::reverse_iterator"""
        return _gcl.VectorString_rbegin(self)


    def rend(self):
        """rend(VectorString self) -> std::vector< std::string >::reverse_iterator"""
        return _gcl.VectorString_rend(self)


    def clear(self):
        """clear(VectorString self)"""
        return _gcl.VectorString_clear(self)


    def get_allocator(self):
        """get_allocator(VectorString self) -> std::vector< std::string >::allocator_type"""
        return _gcl.VectorString_get_allocator(self)


    def pop_back(self):
        """pop_back(VectorString self)"""
        return _gcl.VectorString_pop_back(self)


    def erase(self, *args):
        """
        erase(VectorString self, std::vector< std::string >::iterator pos) -> std::vector< std::string >::iterator
        erase(VectorString self, std::vector< std::string >::iterator first, std::vector< std::string >::iterator last) -> std::vector< std::string >::iterator
        """
        return _gcl.VectorString_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(std::string)> self) -> VectorString
        __init__(std::vector<(std::string)> self, VectorString arg2) -> VectorString
        __init__(std::vector<(std::string)> self, std::vector< std::string >::size_type size) -> VectorString
        __init__(std::vector<(std::string)> self, std::vector< std::string >::size_type size, std::vector< std::string >::value_type const & value) -> VectorString
        """
        this = _gcl.new_VectorString(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """push_back(VectorString self, std::vector< std::string >::value_type const & x)"""
        return _gcl.VectorString_push_back(self, x)


    def front(self):
        """front(VectorString self) -> std::vector< std::string >::value_type const &"""
        return _gcl.VectorString_front(self)


    def back(self):
        """back(VectorString self) -> std::vector< std::string >::value_type const &"""
        return _gcl.VectorString_back(self)


    def assign(self, n, x):
        """assign(VectorString self, std::vector< std::string >::size_type n, std::vector< std::string >::value_type const & x)"""
        return _gcl.VectorString_assign(self, n, x)


    def resize(self, *args):
        """
        resize(VectorString self, std::vector< std::string >::size_type new_size)
        resize(VectorString self, std::vector< std::string >::size_type new_size, std::vector< std::string >::value_type const & x)
        """
        return _gcl.VectorString_resize(self, *args)


    def insert(self, *args):
        """
        insert(VectorString self, std::vector< std::string >::iterator pos, std::vector< std::string >::value_type const & x) -> std::vector< std::string >::iterator
        insert(VectorString self, std::vector< std::string >::iterator pos, std::vector< std::string >::size_type n, std::vector< std::string >::value_type const & x)
        """
        return _gcl.VectorString_insert(self, *args)


    def reserve(self, n):
        """reserve(VectorString self, std::vector< std::string >::size_type n)"""
        return _gcl.VectorString_reserve(self, n)


    def capacity(self):
        """capacity(VectorString self) -> std::vector< std::string >::size_type"""
        return _gcl.VectorString_capacity(self)

    __swig_destroy__ = _gcl.delete_VectorString
    __del__ = lambda self: None
VectorString_swigregister = _gcl.VectorString_swigregister
VectorString_swigregister(VectorString)

class ClassParams(_object):
    """Proxy of C++ ClassParams class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ClassParams, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ClassParams, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(ClassParams self) -> ClassParams
        __init__(ClassParams self, std::string const & param_file) -> ClassParams
        """
        this = _gcl.new_ClassParams(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def _update(self, other):
        """_update(ClassParams self, ClassParams other)"""
        return _gcl.ClassParams__update(self, other)


    def add(self, *args):
        """
        add(ClassParams self, std::string const & key, int const val) -> int
        add(ClassParams self, std::string const & key, long const val) -> int
        add(ClassParams self, std::string const & key, long long const val) -> int
        add(ClassParams self, std::string const & key, unsigned int const val) -> int
        add(ClassParams self, std::string const & key, unsigned long const val) -> int
        add(ClassParams self, std::string const & key, unsigned long long const val) -> int
        add(ClassParams self, std::string const & key, float const val) -> int
        add(ClassParams self, std::string const & key, double const val) -> int
        add(ClassParams self, std::string const & key, long double const val) -> int
        add(ClassParams self, std::string const & key, bool const val) -> int
        add(ClassParams self, std::string const & key, std::string const val) -> int
        add(ClassParams self, std::string const & key, char const * val) -> int
        """
        return _gcl.ClassParams_add(self, *args)


    def keys(self):
        """keys(ClassParams self) -> VectorString"""
        return _gcl.ClassParams_keys(self)


    def size(self):
        """size(ClassParams self) -> unsigned int"""
        return _gcl.ClassParams_size(self)


    def _print(self):
        """_print(ClassParams self)"""
        return _gcl.ClassParams__print(self)


    def pop(self, key):
        """pop(ClassParams self, std::string const & key) -> std::string"""
        return _gcl.ClassParams_pop(self, key)


    def _contains(self, key):
        """_contains(ClassParams self, std::string const & key) -> bool"""
        return _gcl.ClassParams__contains(self, key)


    def _value(self, key):
        """_value(ClassParams self, std::string const & key) -> std::string const &"""
        return _gcl.ClassParams__value(self, key)


    @classmethod
    def from_dict(cls, d):
        toret = cls()

    # default CLASS parameters
        d.setdefault('P_k_max_h/Mpc',  20.)
        d.setdefault('z_max_pk', 2.0)

        for k in d: toret.add(k, d[k])
        return toret

    def update(self, *args, **kwargs):
        if len(args):
            if len(args) != 1:
                raise ValueError("only one positional argument, a dictionary")
            d = args[0]
            if not isinstance(d, dict):
                raise TypeError("first argument must be a dictionary")
            kwargs.update(d)

        if not len(kwargs):
            raise ValueError("no parameters provided to update")
        pars = self.__class__.from_dict(kwargs)
        self._update(pars)

    def __contains__(self, key):
        return self._contains(key)

    def __getitem__(self, key):
        try:
            return self.value(key)
        except:
            raise KeyError("no such key: '%s'" %key)

    def value(self, key):
        value = self._value(key)
        try:
            value = float(value)
        except ValueError:
            pass
        return value

    def __setitem__(self, key, value):
        return self.add(key, value)

    def __iter__(self):
        return iter(self.keys()) 

    def values(self): 
        return [self[k] for k in self.keys()]

    def items(self):
        return list(zip(self.keys(), self.values()))

    def __len__(self):
        return self.size()

    def __str__(self):
        return dict(self).__str__()

    def __repr__(self):
        return dict(self).__repr__()

    @classmethod
    def from_astropy(cls, cosmo, extra={}):
        """
        Convert an astropy cosmology to a ``ClassParams`` instance
        """
        from astropy import units, cosmology

        pars = cls()
        pars['h'] = cosmo.h
        pars['Omega_g'] = cosmo.Ogamma0
        if cosmo.Ob0 is not None:
            pars['Omega_b'] = cosmo.Ob0
        else:
            raise ValueError("please specify a value 'Ob0' ")
        pars['Omega_cdm'] = cosmo.Om0 - cosmo.Ob0 # should be okay for now

    # handle massive neutrinos
        if cosmo.has_massive_nu: 

    # convert to eV
            m_nu = cosmo.m_nu
            if m_nu.unit != units.eV:
                m_nu = m_nu.to(units.eV)

    # from CLASS notes:
    # one more remark: if you have respectively 1,2,3 massive neutrinos, 
    # if you stick to the default value pm equal to 0.71611, designed to give m/omega of 
    # 93.14 eV, and if you want to use N_ur to get N_eff equal to 3.046 in the early universe, 
    # then you should pass here respectively 2.0328,1.0196,0.00641
            N_ur = [2.0328, 1.0196, 0.00641]
            N_massive = (m_nu > 0.).sum()
            pars['N_ur'] = (cosmo.Neff/3.046) * N_ur[N_massive-1]

            pars['N_ncdm'] = N_massive
            pars['m_ncdm'] = ", ".join([str(k.value) for k in sorted(m_nu[m_nu > 0.], reverse=True)])
        else:
            pars['N_ur'] = cosmo.Neff
            pars['N_ncdm'] = 0
            pars['m_ncdm'] = 0.

    # handle dark energy
        if isinstance(cosmo, cosmology.LambdaCDM):
            pars['w0_fld'] = -1.0
            pars['wa_fld'] = 0.
        elif isinstance(cosmo, cosmology.wCDM):
            pars['w0_fld'] = cosmo.w0
            pars['wa_fld'] = 0.
            pars['Omega_Lambda'] = 0. # use Omega_fld
        elif isinstance(cosmo, cosmology.w0waCDM):
            pars['w0_fld'] = cosmo.w0
            pars['wa_fld'] = cosmo.wa
            pars['Omega_Lambda'] = 0. # use Omega_fld
        else:
            cls = cosmo.__class__.__name__
            valid = ["LambdaCDM", "wCDM", "w0waCDM"]
            msg = "dark energy equation of state not recognized for class '%s'; " %cls
            msg += "valid classes: %s" %str(valid)
            raise TypeError(msg)

    # default CLASS parameters
        extra.setdefault('P_k_max_h/Mpc',  20.)
        extra.setdefault('z_max_pk', 2.0)

    # add any extra arguments
        if len(extra):
            pars.update(extra)

        return pars

    __swig_destroy__ = _gcl.delete_ClassParams
    __del__ = lambda self: None
ClassParams_swigregister = _gcl.ClassParams_swigregister
ClassParams_swigregister(ClassParams)

class VectorUnsigned(_object):
    """Proxy of C++ std::vector<(unsigned int)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorUnsigned, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VectorUnsigned, name)
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(VectorUnsigned self) -> SwigPyIterator"""
        return _gcl.VectorUnsigned_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(VectorUnsigned self) -> bool"""
        return _gcl.VectorUnsigned___nonzero__(self)


    def __bool__(self):
        """__bool__(VectorUnsigned self) -> bool"""
        return _gcl.VectorUnsigned___bool__(self)


    def __len__(self):
        """__len__(VectorUnsigned self) -> std::vector< unsigned int >::size_type"""
        return _gcl.VectorUnsigned___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(VectorUnsigned self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j) -> VectorUnsigned"""
        return _gcl.VectorUnsigned___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(VectorUnsigned self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j)
        __setslice__(VectorUnsigned self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j, VectorUnsigned v)
        """
        return _gcl.VectorUnsigned___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(VectorUnsigned self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j)"""
        return _gcl.VectorUnsigned___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(VectorUnsigned self, std::vector< unsigned int >::difference_type i)
        __delitem__(VectorUnsigned self, PySliceObject * slice)
        """
        return _gcl.VectorUnsigned___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(VectorUnsigned self, PySliceObject * slice) -> VectorUnsigned
        __getitem__(VectorUnsigned self, std::vector< unsigned int >::difference_type i) -> std::vector< unsigned int >::value_type const &
        """
        return _gcl.VectorUnsigned___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(VectorUnsigned self, PySliceObject * slice, VectorUnsigned v)
        __setitem__(VectorUnsigned self, PySliceObject * slice)
        __setitem__(VectorUnsigned self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::value_type const & x)
        """
        return _gcl.VectorUnsigned___setitem__(self, *args)


    def pop(self):
        """pop(VectorUnsigned self) -> std::vector< unsigned int >::value_type"""
        return _gcl.VectorUnsigned_pop(self)


    def append(self, x):
        """append(VectorUnsigned self, std::vector< unsigned int >::value_type const & x)"""
        return _gcl.VectorUnsigned_append(self, x)


    def empty(self):
        """empty(VectorUnsigned self) -> bool"""
        return _gcl.VectorUnsigned_empty(self)


    def size(self):
        """size(VectorUnsigned self) -> std::vector< unsigned int >::size_type"""
        return _gcl.VectorUnsigned_size(self)


    def swap(self, v):
        """swap(VectorUnsigned self, VectorUnsigned v)"""
        return _gcl.VectorUnsigned_swap(self, v)


    def begin(self):
        """begin(VectorUnsigned self) -> std::vector< unsigned int >::iterator"""
        return _gcl.VectorUnsigned_begin(self)


    def end(self):
        """end(VectorUnsigned self) -> std::vector< unsigned int >::iterator"""
        return _gcl.VectorUnsigned_end(self)


    def rbegin(self):
        """rbegin(VectorUnsigned self) -> std::vector< unsigned int >::reverse_iterator"""
        return _gcl.VectorUnsigned_rbegin(self)


    def rend(self):
        """rend(VectorUnsigned self) -> std::vector< unsigned int >::reverse_iterator"""
        return _gcl.VectorUnsigned_rend(self)


    def clear(self):
        """clear(VectorUnsigned self)"""
        return _gcl.VectorUnsigned_clear(self)


    def get_allocator(self):
        """get_allocator(VectorUnsigned self) -> std::vector< unsigned int >::allocator_type"""
        return _gcl.VectorUnsigned_get_allocator(self)


    def pop_back(self):
        """pop_back(VectorUnsigned self)"""
        return _gcl.VectorUnsigned_pop_back(self)


    def erase(self, *args):
        """
        erase(VectorUnsigned self, std::vector< unsigned int >::iterator pos) -> std::vector< unsigned int >::iterator
        erase(VectorUnsigned self, std::vector< unsigned int >::iterator first, std::vector< unsigned int >::iterator last) -> std::vector< unsigned int >::iterator
        """
        return _gcl.VectorUnsigned_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(unsigned int)> self) -> VectorUnsigned
        __init__(std::vector<(unsigned int)> self, VectorUnsigned arg2) -> VectorUnsigned
        __init__(std::vector<(unsigned int)> self, std::vector< unsigned int >::size_type size) -> VectorUnsigned
        __init__(std::vector<(unsigned int)> self, std::vector< unsigned int >::size_type size, std::vector< unsigned int >::value_type const & value) -> VectorUnsigned
        """
        this = _gcl.new_VectorUnsigned(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """push_back(VectorUnsigned self, std::vector< unsigned int >::value_type const & x)"""
        return _gcl.VectorUnsigned_push_back(self, x)


    def front(self):
        """front(VectorUnsigned self) -> std::vector< unsigned int >::value_type const &"""
        return _gcl.VectorUnsigned_front(self)


    def back(self):
        """back(VectorUnsigned self) -> std::vector< unsigned int >::value_type const &"""
        return _gcl.VectorUnsigned_back(self)


    def assign(self, n, x):
        """assign(VectorUnsigned self, std::vector< unsigned int >::size_type n, std::vector< unsigned int >::value_type const & x)"""
        return _gcl.VectorUnsigned_assign(self, n, x)


    def resize(self, *args):
        """
        resize(VectorUnsigned self, std::vector< unsigned int >::size_type new_size)
        resize(VectorUnsigned self, std::vector< unsigned int >::size_type new_size, std::vector< unsigned int >::value_type const & x)
        """
        return _gcl.VectorUnsigned_resize(self, *args)


    def insert(self, *args):
        """
        insert(VectorUnsigned self, std::vector< unsigned int >::iterator pos, std::vector< unsigned int >::value_type const & x) -> std::vector< unsigned int >::iterator
        insert(VectorUnsigned self, std::vector< unsigned int >::iterator pos, std::vector< unsigned int >::size_type n, std::vector< unsigned int >::value_type const & x)
        """
        return _gcl.VectorUnsigned_insert(self, *args)


    def reserve(self, n):
        """reserve(VectorUnsigned self, std::vector< unsigned int >::size_type n)"""
        return _gcl.VectorUnsigned_reserve(self, n)


    def capacity(self):
        """capacity(VectorUnsigned self) -> std::vector< unsigned int >::size_type"""
        return _gcl.VectorUnsigned_capacity(self)

    __swig_destroy__ = _gcl.delete_VectorUnsigned
    __del__ = lambda self: None
VectorUnsigned_swigregister = _gcl.VectorUnsigned_swigregister
VectorUnsigned_swigregister(VectorUnsigned)


import contextlib

class cltypes(_object):
    """Proxy of C++ Cls class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cltypes, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cltypes, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    TT = _gcl.cltypes_TT
    EE = _gcl.cltypes_EE
    TE = _gcl.cltypes_TE
    BB = _gcl.cltypes_BB
    PP = _gcl.cltypes_PP
    TP = _gcl.cltypes_TP
cltypes_swigregister = _gcl.cltypes_swigregister
cltypes_swigregister(cltypes)

class ClassEngine(_object):
    """Proxy of C++ ClassEngine class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ClassEngine, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ClassEngine, name)
    __repr__ = _swig_repr
    __swig_setmethods__["Alpha_inf_hyrec_file"] = _gcl.ClassEngine_Alpha_inf_hyrec_file_set
    __swig_getmethods__["Alpha_inf_hyrec_file"] = _gcl.ClassEngine_Alpha_inf_hyrec_file_get
    if _newclass:
        Alpha_inf_hyrec_file = _swig_property(_gcl.ClassEngine_Alpha_inf_hyrec_file_get, _gcl.ClassEngine_Alpha_inf_hyrec_file_set)
    __swig_setmethods__["R_inf_hyrec_file"] = _gcl.ClassEngine_R_inf_hyrec_file_set
    __swig_getmethods__["R_inf_hyrec_file"] = _gcl.ClassEngine_R_inf_hyrec_file_get
    if _newclass:
        R_inf_hyrec_file = _swig_property(_gcl.ClassEngine_R_inf_hyrec_file_get, _gcl.ClassEngine_R_inf_hyrec_file_set)
    __swig_setmethods__["two_photon_tables_hyrec_file"] = _gcl.ClassEngine_two_photon_tables_hyrec_file_set
    __swig_getmethods__["two_photon_tables_hyrec_file"] = _gcl.ClassEngine_two_photon_tables_hyrec_file_get
    if _newclass:
        two_photon_tables_hyrec_file = _swig_property(_gcl.ClassEngine_two_photon_tables_hyrec_file_get, _gcl.ClassEngine_two_photon_tables_hyrec_file_set)
    __swig_setmethods__["sBBN_file"] = _gcl.ClassEngine_sBBN_file_set
    __swig_getmethods__["sBBN_file"] = _gcl.ClassEngine_sBBN_file_get
    if _newclass:
        sBBN_file = _swig_property(_gcl.ClassEngine_sBBN_file_get, _gcl.ClassEngine_sBBN_file_set)

    def __init__(self, verbose=False):
        """__init__(ClassEngine self, bool verbose=False) -> ClassEngine"""
        this = _gcl.new_ClassEngine(verbose)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gcl.delete_ClassEngine
    __del__ = lambda self: None

    def _compute(self, *args):
        """
        _compute(ClassEngine self, std::string const & param_file)
        _compute(ClassEngine self)
        _compute(ClassEngine self, ClassParams pars)
        """
        return _gcl.ClassEngine__compute(self, *args)


    def isready(self):
        """isready(ClassEngine self) -> bool"""
        return _gcl.ClassEngine_isready(self)


    def verbose(self, verbose=True):
        """verbose(ClassEngine self, bool verbose=True)"""
        return _gcl.ClassEngine_verbose(self, verbose)


    def GetRawCls(self, *args, **kwargs):
        """GetRawCls(ClassEngine self, parray const & ell, Cls::Type cl) -> parray"""
        return _gcl.ClassEngine_GetRawCls(self, *args, **kwargs)


    def GetLensedCls(self, *args, **kwargs):
        """GetLensedCls(ClassEngine self, parray const & ell, Cls::Type cl) -> parray"""
        return _gcl.ClassEngine_GetLensedCls(self, *args, **kwargs)


    def GetPklin(self, k, z):
        """GetPklin(ClassEngine self, parray const & k, double z) -> parray"""
        return _gcl.ClassEngine_GetPklin(self, k, z)


    def GetPknl(self, k, z):
        """GetPknl(ClassEngine self, parray const & k, double z) -> parray"""
        return _gcl.ClassEngine_GetPknl(self, k, z)


    def GetTk(self, k, z):
        """GetTk(ClassEngine self, parray const & k, double z) -> parray"""
        return _gcl.ClassEngine_GetTk(self, k, z)


    def lmax(self):
        """lmax(ClassEngine self) -> int"""
        return _gcl.ClassEngine_lmax(self)


    def lensed_lmax(self):
        """lensed_lmax(ClassEngine self) -> int"""
        return _gcl.ClassEngine_lensed_lmax(self)


    def H0(self):
        """H0(ClassEngine self) -> double"""
        return _gcl.ClassEngine_H0(self)


    def h(self):
        """h(ClassEngine self) -> double"""
        return _gcl.ClassEngine_h(self)


    def Tcmb(self):
        """Tcmb(ClassEngine self) -> double"""
        return _gcl.ClassEngine_Tcmb(self)


    def Omega0_b(self):
        """Omega0_b(ClassEngine self) -> double"""
        return _gcl.ClassEngine_Omega0_b(self)


    def Omega0_cdm(self):
        """Omega0_cdm(ClassEngine self) -> double"""
        return _gcl.ClassEngine_Omega0_cdm(self)


    def Omega0_ur(self):
        """Omega0_ur(ClassEngine self) -> double"""
        return _gcl.ClassEngine_Omega0_ur(self)


    def Omega0_m(self):
        """Omega0_m(ClassEngine self) -> double"""
        return _gcl.ClassEngine_Omega0_m(self)


    def Omega0_r(self):
        """Omega0_r(ClassEngine self) -> double"""
        return _gcl.ClassEngine_Omega0_r(self)


    def Omega0_g(self):
        """Omega0_g(ClassEngine self) -> double"""
        return _gcl.ClassEngine_Omega0_g(self)


    def Omega0_lambda(self):
        """Omega0_lambda(ClassEngine self) -> double"""
        return _gcl.ClassEngine_Omega0_lambda(self)


    def Omega0_fld(self):
        """Omega0_fld(ClassEngine self) -> double"""
        return _gcl.ClassEngine_Omega0_fld(self)


    def Omega0_k(self):
        """Omega0_k(ClassEngine self) -> double"""
        return _gcl.ClassEngine_Omega0_k(self)


    def w0_fld(self):
        """w0_fld(ClassEngine self) -> double"""
        return _gcl.ClassEngine_w0_fld(self)


    def wa_fld(self):
        """wa_fld(ClassEngine self) -> double"""
        return _gcl.ClassEngine_wa_fld(self)


    def n_s(self):
        """n_s(ClassEngine self) -> double"""
        return _gcl.ClassEngine_n_s(self)


    def k_pivot(self):
        """k_pivot(ClassEngine self) -> double"""
        return _gcl.ClassEngine_k_pivot(self)


    def A_s(self):
        """A_s(ClassEngine self) -> double"""
        return _gcl.ClassEngine_A_s(self)


    def ln_1e10_A_s(self):
        """ln_1e10_A_s(ClassEngine self) -> double"""
        return _gcl.ClassEngine_ln_1e10_A_s(self)


    def sigma8(self):
        """sigma8(ClassEngine self) -> double"""
        return _gcl.ClassEngine_sigma8(self)


    def k_max(self):
        """k_max(ClassEngine self) -> double"""
        return _gcl.ClassEngine_k_max(self)


    def k_min(self):
        """k_min(ClassEngine self) -> double"""
        return _gcl.ClassEngine_k_min(self)


    def z_drag(self):
        """z_drag(ClassEngine self) -> double"""
        return _gcl.ClassEngine_z_drag(self)


    def rs_drag(self):
        """rs_drag(ClassEngine self) -> double"""
        return _gcl.ClassEngine_rs_drag(self)


    def tau_reio(self):
        """tau_reio(ClassEngine self) -> double"""
        return _gcl.ClassEngine_tau_reio(self)


    def z_reio(self):
        """z_reio(ClassEngine self) -> double"""
        return _gcl.ClassEngine_z_reio(self)


    def f_z(self, *args):
        """
        f_z(ClassEngine self, double z) -> double
        f_z(ClassEngine self, parray const & z) -> parray
        """
        return _gcl.ClassEngine_f_z(self, *args)


    def H_z(self, *args):
        """
        H_z(ClassEngine self, double z) -> double
        H_z(ClassEngine self, parray const & z) -> parray
        """
        return _gcl.ClassEngine_H_z(self, *args)


    def Da_z(self, *args):
        """
        Da_z(ClassEngine self, double z) -> double
        Da_z(ClassEngine self, parray const & z) -> parray
        """
        return _gcl.ClassEngine_Da_z(self, *args)


    def Dc_z(self, *args):
        """
        Dc_z(ClassEngine self, double z) -> double
        Dc_z(ClassEngine self, parray const & z) -> parray
        """
        return _gcl.ClassEngine_Dc_z(self, *args)


    def Dm_z(self, *args):
        """
        Dm_z(ClassEngine self, double z) -> double
        Dm_z(ClassEngine self, parray const & z) -> parray
        """
        return _gcl.ClassEngine_Dm_z(self, *args)


    def D_z(self, *args):
        """
        D_z(ClassEngine self, double z) -> double
        D_z(ClassEngine self, parray const & z) -> parray
        """
        return _gcl.ClassEngine_D_z(self, *args)


    def Sigma8_z(self, *args):
        """
        Sigma8_z(ClassEngine self, double z) -> double
        Sigma8_z(ClassEngine self, parray const & z) -> parray
        """
        return _gcl.ClassEngine_Sigma8_z(self, *args)


    def Omega_m_z(self, *args):
        """
        Omega_m_z(ClassEngine self, double z) -> double
        Omega_m_z(ClassEngine self, parray const & z) -> parray
        """
        return _gcl.ClassEngine_Omega_m_z(self, *args)


    def rho_bar_z(self, *args):
        """
        rho_bar_z(ClassEngine self, double z, bool cgs=False) -> double
        rho_bar_z(ClassEngine self, parray const & z, bool cgs=False) -> parray
        """
        return _gcl.ClassEngine_rho_bar_z(self, *args)


    def rho_crit_z(self, *args):
        """
        rho_crit_z(ClassEngine self, double z, bool cgs=False) -> double
        rho_crit_z(ClassEngine self, parray const & z, bool cgs=False) -> parray
        """
        return _gcl.ClassEngine_rho_crit_z(self, *args)


    def dV(self, *args):
        """
        dV(ClassEngine self, double z) -> double
        dV(ClassEngine self, parray const & z) -> parray
        """
        return _gcl.ClassEngine_dV(self, *args)


    def V(self, *args):
        """
        V(ClassEngine self, double zmin, double zmax, int Nz=1024) -> double
        V(ClassEngine self, parray const & zmin, parray const & zmax, int Nz=1024) -> parray
        """
        return _gcl.ClassEngine_V(self, *args)


    def _clean(self):
        """_clean(ClassEngine self)"""
        return _gcl.ClassEngine__clean(self)



    @contextlib.contextmanager
    def compute(self, *args):

        try:
            self._compute(*args)
            yield
        except Exception as e:
            raise e
        finally:
            self._clean()

ClassEngine_swigregister = _gcl.ClassEngine_swigregister
ClassEngine_swigregister(ClassEngine)
cvar = _gcl.cvar

class transfers(_object):
    """Proxy of C++ TransferFit class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, transfers, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, transfers, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    CLASS = _gcl.transfers_CLASS
    EH = _gcl.transfers_EH
    EH_NoWiggle = _gcl.transfers_EH_NoWiggle
    BBKS = _gcl.transfers_BBKS
transfers_swigregister = _gcl.transfers_swigregister
transfers_swigregister(transfers)

class Cosmology(ClassEngine):
    """Proxy of C++ Cosmology class."""

    __swig_setmethods__ = {}
    for _s in [ClassEngine]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Cosmology, name, value)
    __swig_getmethods__ = {}
    for _s in [ClassEngine]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Cosmology, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _gcl.delete_Cosmology
    __del__ = lambda self: None

    def __init__(self, *args):
        """
        __init__(Cosmology self, bool verbose=False) -> Cosmology
        __init__(Cosmology self, TransferFit::Type tf, bool verbose=False) -> Cosmology
        __init__(Cosmology self, std::string const & param_file, bool verbose=False) -> Cosmology
        __init__(Cosmology self, std::string const & param_file, TransferFit::Type tf, bool verbose=False) -> Cosmology
        __init__(Cosmology self, ClassParams pars, bool verbose=False) -> Cosmology
        __init__(Cosmology self, ClassParams pars, TransferFit::Type tf, bool verbose=False) -> Cosmology
        __init__(Cosmology self, Cosmology other) -> Cosmology
        """
        this = _gcl.new_Cosmology(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def verbose(self, verbose=True):
        """verbose(Cosmology self, bool verbose=True)"""
        return _gcl.Cosmology_verbose(self, verbose)


    def SetTransferFunction(self, tf):
        """SetTransferFunction(Cosmology self, TransferFit::Type tf)"""
        return _gcl.Cosmology_SetTransferFunction(self, tf)


    def NormalizeTransferFunction(self, sigma8):
        """NormalizeTransferFunction(Cosmology self, double sigma8)"""
        return _gcl.Cosmology_NormalizeTransferFunction(self, sigma8)


    def SetSigma8(self, sigma8):
        """SetSigma8(Cosmology self, double sigma8)"""
        return _gcl.Cosmology_SetSigma8(self, sigma8)


    def _update(self, newpars):
        """_update(Cosmology self, ClassParams newpars)"""
        return _gcl.Cosmology__update(self, newpars)


    def A_s(self):
        """A_s(Cosmology self) -> double"""
        return _gcl.Cosmology_A_s(self)


    def ln_1e10_A_s(self):
        """ln_1e10_A_s(Cosmology self) -> double"""
        return _gcl.Cosmology_ln_1e10_A_s(self)


    def delta_H(self):
        """delta_H(Cosmology self) -> double"""
        return _gcl.Cosmology_delta_H(self)


    def sigma8(self):
        """sigma8(Cosmology self) -> double"""
        return _gcl.Cosmology_sigma8(self)


    def GetTransferFit(self):
        """GetTransferFit(Cosmology self) -> TransferFit::Type"""
        return _gcl.Cosmology_GetTransferFit(self)


    def GetParamFile(self):
        """GetParamFile(Cosmology self) -> std::string const &"""
        return _gcl.Cosmology_GetParamFile(self)


    def GetDiscreteK(self):
        """GetDiscreteK(Cosmology self) -> parray"""
        return _gcl.Cosmology_GetDiscreteK(self)


    def GetDiscreteTk(self):
        """GetDiscreteTk(Cosmology self) -> parray"""
        return _gcl.Cosmology_GetDiscreteTk(self)


    def EvaluateTransfer(self, k):
        """EvaluateTransfer(Cosmology self, double k) -> double"""
        return _gcl.Cosmology_EvaluateTransfer(self, k)



    def update(self, *args, **kwargs):
        if len(args):
            if len(args) != 1:
                raise ValueError("only one positional argument, a dictionary")
            d = args[0]
            if not isinstance(d, dict):
                raise TypeError("first argument must be a dictionary")
            kwargs.update(d)

        if not len(kwargs):
            raise ValueError("no parameters provided to update")
        pars = ClassParams.from_dict(kwargs)
        self._update(pars)

Cosmology_swigregister = _gcl.Cosmology_swigregister
Cosmology_swigregister(Cosmology)

class PowerSpectrum(_object):
    """Proxy of C++ PowerSpectrum class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PowerSpectrum, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PowerSpectrum, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _gcl.delete_PowerSpectrum
    __del__ = lambda self: None

    def __call__(self, *args):
        """
        __call__(PowerSpectrum self, double const k) -> double
        __call__(PowerSpectrum self, parray const & k) -> parray
        """
        return _gcl.PowerSpectrum___call__(self, *args)


    def GetCosmology(self):
        """GetCosmology(PowerSpectrum self) -> Cosmology"""
        return _gcl.PowerSpectrum_GetCosmology(self)


    def Sigma(self, *args):
        """
        Sigma(PowerSpectrum self, double R) -> double
        Sigma(PowerSpectrum self, parray const & R) -> parray
        """
        return _gcl.PowerSpectrum_Sigma(self, *args)


    def NonlinearScale(self):
        """NonlinearScale(PowerSpectrum self) -> double"""
        return _gcl.PowerSpectrum_NonlinearScale(self)


    def VelocityDispersion(self, *args):
        """
        VelocityDispersion(PowerSpectrum self) -> double
        VelocityDispersion(PowerSpectrum self, parray const & k, double factor=0.5) -> parray
        VelocityDispersion(PowerSpectrum self, double const k, double factor=0.5) -> double
        """
        return _gcl.PowerSpectrum_VelocityDispersion(self, *args)


    def X_Zel(self, *args):
        """
        X_Zel(PowerSpectrum self, parray const & k) -> parray
        X_Zel(PowerSpectrum self, double const k) -> double
        """
        return _gcl.PowerSpectrum_X_Zel(self, *args)


    def Y_Zel(self, *args):
        """
        Y_Zel(PowerSpectrum self, parray const & k) -> parray
        Y_Zel(PowerSpectrum self, double const k) -> double
        """
        return _gcl.PowerSpectrum_Y_Zel(self, *args)


    def Q3_Zel(self, *args):
        """
        Q3_Zel(PowerSpectrum self, parray const & k) -> parray
        Q3_Zel(PowerSpectrum self, double const k) -> double
        """
        return _gcl.PowerSpectrum_Q3_Zel(self, *args)

PowerSpectrum_swigregister = _gcl.PowerSpectrum_swigregister
PowerSpectrum_swigregister(PowerSpectrum)

class LinearPS(PowerSpectrum):
    """Proxy of C++ LinearPS class."""

    __swig_setmethods__ = {}
    for _s in [PowerSpectrum]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LinearPS, name, value)
    __swig_getmethods__ = {}
    for _s in [PowerSpectrum]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LinearPS, name)
    __repr__ = _swig_repr

    def __init__(self, cosmo, z=0):
        """__init__(LinearPS self, Cosmology cosmo, double z=0) -> LinearPS"""
        this = _gcl.new_LinearPS(cosmo, z)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gcl.delete_LinearPS
    __del__ = lambda self: None

    def Evaluate(self, k):
        """Evaluate(LinearPS self, double k) -> double"""
        return _gcl.LinearPS_Evaluate(self, k)


    def GetSigma8AtZ(self):
        """GetSigma8AtZ(LinearPS self) -> double const &"""
        return _gcl.LinearPS_GetSigma8AtZ(self)


    def GetCosmology(self):
        """GetCosmology(LinearPS self) -> Cosmology"""
        return _gcl.LinearPS_GetCosmology(self)


    def GetRedshift(self):
        """GetRedshift(LinearPS self) -> double const &"""
        return _gcl.LinearPS_GetRedshift(self)


    def SetSigma8AtZ(self, sigma8_z):
        """SetSigma8AtZ(LinearPS self, double sigma8_z)"""
        return _gcl.LinearPS_SetSigma8AtZ(self, sigma8_z)


    def _update(self, newpars):
        """_update(LinearPS self, ClassParams newpars)"""
        return _gcl.LinearPS__update(self, newpars)



    def update(self, *args, **kwargs):
        if len(args):
            if len(args) != 1:
                raise ValueError("only one positional argument, a dictionary")
            d = args[0]
            if not isinstance(d, dict):
                raise TypeError("first argument must be a dictionary")
            kwargs.update(d)

        if not len(kwargs):
            raise ValueError("no parameters provided to update")
        pars = ClassParams.from_dict(kwargs)
        self._update(pars)

LinearPS_swigregister = _gcl.LinearPS_swigregister
LinearPS_swigregister(LinearPS)

class ZeldovichPS(_object):
    """Proxy of C++ ZeldovichPS class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ZeldovichPS, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ZeldovichPS, name)
    __repr__ = _swig_repr

    def __init__(self, C, z, approx_lowk=False):
        """__init__(ZeldovichPS self, Cosmology C, double z, bool approx_lowk=False) -> ZeldovichPS"""
        this = _gcl.new_ZeldovichPS(C, z, approx_lowk)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gcl.delete_ZeldovichPS
    __del__ = lambda self: None

    def __call__(self, *args):
        """
        __call__(ZeldovichPS self, double const k) -> double
        __call__(ZeldovichPS self, parray const & k) -> parray
        """
        return _gcl.ZeldovichPS___call__(self, *args)


    def SetLowKApprox(self, approx_lowk_=True):
        """SetLowKApprox(ZeldovichPS self, bool approx_lowk_=True)"""
        return _gcl.ZeldovichPS_SetLowKApprox(self, approx_lowk_)


    def SetLowKTransition(self, k0):
        """SetLowKTransition(ZeldovichPS self, double k0)"""
        return _gcl.ZeldovichPS_SetLowKTransition(self, k0)


    def LowKApprox(self, k):
        """LowKApprox(ZeldovichPS self, double k) -> double"""
        return _gcl.ZeldovichPS_LowKApprox(self, k)


    def GetSigma8AtZ(self):
        """GetSigma8AtZ(ZeldovichPS self) -> double const &"""
        return _gcl.ZeldovichPS_GetSigma8AtZ(self)


    def GetCosmology(self):
        """GetCosmology(ZeldovichPS self) -> Cosmology"""
        return _gcl.ZeldovichPS_GetCosmology(self)


    def GetApproxLowKFlag(self):
        """GetApproxLowKFlag(ZeldovichPS self) -> bool const &"""
        return _gcl.ZeldovichPS_GetApproxLowKFlag(self)


    def GetK0Low(self):
        """GetK0Low(ZeldovichPS self) -> double const &"""
        return _gcl.ZeldovichPS_GetK0Low(self)


    def GetXZel(self):
        """GetXZel(ZeldovichPS self) -> parray"""
        return _gcl.ZeldovichPS_GetXZel(self)


    def GetYZel(self):
        """GetYZel(ZeldovichPS self) -> parray"""
        return _gcl.ZeldovichPS_GetYZel(self)


    def GetX0Zel(self):
        """GetX0Zel(ZeldovichPS self) -> parray"""
        return _gcl.ZeldovichPS_GetX0Zel(self)


    def GetSigmaSq(self):
        """GetSigmaSq(ZeldovichPS self) -> double const &"""
        return _gcl.ZeldovichPS_GetSigmaSq(self)


    def SetSigma8AtZ(self, sigma8):
        """SetSigma8AtZ(ZeldovichPS self, double sigma8)"""
        return _gcl.ZeldovichPS_SetSigma8AtZ(self, sigma8)

ZeldovichPS_swigregister = _gcl.ZeldovichPS_swigregister
ZeldovichPS_swigregister(ZeldovichPS)

# This file is compatible with both classic and new-style classes.


